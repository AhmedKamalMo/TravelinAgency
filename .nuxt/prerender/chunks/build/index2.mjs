import{computed as e,defineComponent as a,h as t,onServerPrefetch as n,ref as r,shallowRef as s,toRef as o,getCurrentInstance as i,unref as l}from"file://F:/TravelinAgency/node_modules/vue/index.mjs";import{getIconCSS as c}from"file://F:/TravelinAgency/node_modules/@iconify/utils/lib/css/icon.mjs";import{getIcon as u,loadIcon as d,Icon as m}from"file://F:/TravelinAgency/node_modules/@iconify/vue/dist/iconify.mjs";import{e as f,S as y,T as p,H as v,f as _,u as h}from"./server.mjs";async function m$1(e,a){if(!e)return null;const t=u(e);if(t)return t;let n;const r=d(e).catch((()=>(console.warn(`[Icon] failed to load icon \`${e}\``),null)));return a>0?await Promise.race([r,new Promise((t=>{n=setTimeout((()=>{console.warn(`[Icon] loading icon \`${e}\` timed out after ${a}ms`),t()}),a)}))]).finally((()=>clearTimeout(n))):await r,u(e)}function I$1(a){const t=f().icon,n=(t.collections||[]).sort(((e,a)=>a.length-e.length));return e((()=>{var e;const r=a(),s=r.startsWith(t.cssSelectorPrefix)?r.slice(t.cssSelectorPrefix.length):r,o=(null==(e=t.aliases)?void 0:e[s])||s;if(!o.includes(":")){const e=n.find((e=>o.startsWith(e+"-")));return e?e+":"+o.slice(e.length+1):o}return o}))}function w$1(e,a){if(!1!==e)return!0===e||null===e?a:e}const g="NUXT_ICONS_SERVER_CSS";const D=a({name:"NuxtIconCss",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(a){const r=y(),s=f().icon,o=e((()=>a.name?s.cssSelectorPrefix+a.name:"")),i=e((()=>"."+function(e){return e.replace(/([^\w-])/g,"\\$1")}(o.value)));return n((async()=>{var e;{const t=p().icon||{};if(null==(e=null==t?void 0:t.serverKnownCssClasses)||!e.includes(o.value)){const e=await m$1(a.name,s.fetchTimeout).catch((()=>null));if(!e)return null;let t=r.vueApp._context.provides[g];if(t||(t=r.vueApp._context.provides[g]=new Map,r.runWithContext((()=>{v({style:[()=>{let e=Array.from(t.values()).sort().join("");return s.cssLayer&&(e=`@layer ${s.cssLayer} {${e}}`),{innerHTML:e}}]},{tagPriority:"low"})}))),a.name&&!t.has(a.name)){const n=function(e,t=!0){let n=i.value;s.cssWherePseudo&&(n=`:where(${n})`);const r=c(e,{iconSelector:n,format:"compressed",customise:w$1(a.customize,s.customize)});return s.cssLayer&&t?`@layer ${s.cssLayer} { ${r} }`:r}(e,!1);t.set(a.name,n)}return null}}})),()=>t("span",{class:["iconify",o.value]})}});function I(...e){var a,t;const c="string"==typeof e[e.length-1]?e.pop():void 0;"string"!=typeof e[0]&&e.unshift(c);let[u,d,m={}]=e;if("string"!=typeof u)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof d)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const f=y(),p=null!=(a=f.ssrContext)&&a._sharedPrerenderCache?()=>{const e=f.ssrContext._sharedPrerenderCache.get(u);if(e)return e;const a=Promise.resolve().then((()=>f.runWithContext(d)));return f.ssrContext._sharedPrerenderCache.set(u,a),a}:d;m.server??(m.server=!0),m.default??(m.default=()=>_.value),m.getCachedData??(m.getCachedData=()=>f.isHydrating?f.payload.data[u]:f.static.data[u]),m.lazy??(m.lazy=!1),m.immediate??(m.immediate=!0),m.deep??(m.deep=_.deep),m.dedupe??(m.dedupe="cancel");const v=m.getCachedData(u,f),g=null!=v;if(!f._asyncData[u]||!m.immediate){(t=f.payload._errors)[u]??(t[u]=_.errorValue);const e=m.deep?r:s;f._asyncData[u]={data:e(g?v:m.default()),pending:r(!g),error:o(f.payload._errors,u),status:r("idle"),_default:m.default}}const D={...f._asyncData[u]};delete D._default,D.refresh=D.execute=(e={})=>{if(f._asyncDataPromises[u]){if((e=>"defer"===e||!1===e)(e.dedupe??m.dedupe))return f._asyncDataPromises[u];f._asyncDataPromises[u].cancelled=!0}if(e._initial||f.isHydrating&&!1!==e._initial){const a=e._initial?v:m.getCachedData(u,f);if(null!=a)return Promise.resolve(a)}D.pending.value=!0,D.status.value="pending";const a=new Promise(((e,a)=>{try{e(p(f))}catch(e){a(e)}})).then((async e=>{if(a.cancelled)return f._asyncDataPromises[u];let t=e;m.transform&&(t=await m.transform(e)),m.pick&&(t=function(e,a){const t={};for(const n of a)t[n]=e[n];return t}(t,m.pick)),f.payload.data[u]=t,D.data.value=t,D.error.value=_.errorValue,D.status.value="success"})).catch((e=>{if(a.cancelled)return f._asyncDataPromises[u];D.error.value=h(e),D.data.value=l(m.default()),D.status.value="error"})).finally((()=>{a.cancelled||(D.pending.value=!1,delete f._asyncDataPromises[u])}));return f._asyncDataPromises[u]=a,f._asyncDataPromises[u]},D.clear=()=>function(e,a){a in e.payload.data&&(e.payload.data[a]=void 0),a in e.payload._errors&&(e.payload._errors[a]=_.errorValue),e._asyncData[a]&&(e._asyncData[a].data.value=void 0,e._asyncData[a].error.value=_.errorValue,e._asyncData[a].pending.value=!1,e._asyncData[a].status.value="idle"),a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=!0),e._asyncDataPromises[a]=void 0)}(f,u);if(!1!==m.server&&f.payload.serverRendered&&m.immediate){const e=D.refresh({_initial:!0});i()?n((()=>e)):f.hook("app:created",(async()=>{await e}))}const P=Promise.resolve(f._asyncDataPromises[u]).then((()=>D));return Object.assign(P,D),P}const P=a({name:"NuxtIconSvg",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(e,{slots:a}){y();const r=f().icon,s=I$1((()=>e.name)),o="i-"+s.value;return s.value&&n((async()=>{await I(o,(async()=>await m$1(s.value,r.fetchTimeout)),{deep:!1})})),()=>t(m,{icon:s.value,ssr:!0,customise:w$1(e.customize,r.customize)},a)}}),w=a({name:"NuxtIcon",props:{name:{type:String,required:!0},mode:{type:String,required:!1,default:null},size:{type:[Number,String],required:!1,default:null},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(a,{slots:n}){const r=y(),s=f().icon,o=I$1((()=>a.name)),i=e((()=>{var e;return(null==(e=r.vueApp)?void 0:e.component(o.value))||("svg"===(a.mode||s.mode)?P:D)})),l=e((()=>{const e=a.size||s.size;return e?{fontSize:Number.isNaN(+e)?e:e+"px"}:null}));return()=>t(i.value,{...s.attrs,name:o.value,class:s.class,style:l.value,customize:a.customize},n)}}),x=Object.freeze({__proto__:null,default:w});export{I,x as i,w as q};
//# sourceMappingURL=index2.mjs.map
