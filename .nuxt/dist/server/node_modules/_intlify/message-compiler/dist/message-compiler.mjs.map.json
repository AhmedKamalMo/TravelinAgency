{"file":"message-compiler.mjs","mappings":"8FAAA;AAAA;AAAA;AAAA;AAAA,IAWA,SAASA,GAAeC,EAAMC,EAAQC,EAAQ,CACnC,MAAA,CAAE,KAAAF,EAAM,OAAAC,EAAQ,OAAAC,CAAO,CAClC,CACA,SAASC,EAAeC,EAAOC,EAAKC,EAAQ,CAKjC,MAJK,CAAE,MAAAF,EAAO,IAAAC,CAAI,CAK7B,CAEA,MAAME,GAAmB,CACrB,kBAAmB,EACnB,iBAAkB,CACtB,EAEMC,GAAe,CACjB,CAACD,GAAiB,iBAAiB,EAAG,4BAC1C,EACA,SAASE,GAAkBC,EAAMC,KAAQC,EAAM,CAC3C,MAAMC,EAAO,QAAQ,IAAI,WAAa,aAAgBC,GAAON,GAAaE,CAAI,EAAS,GAAIE,GAAQ,CAAA,CAAG,EAAIF,EACpGK,EAAU,CAAE,QAAS,OAAOF,CAAG,EAAG,KAAAH,CAAK,EAC7C,OAAIC,IACAI,EAAQ,SAAWJ,GAEhBI,CACX,CAEA,MAAMC,EAAoB,CAEtB,eAAgB,EAChB,6BAA8B,EAC9B,yCAA0C,EAC1C,wBAAyB,EACzB,gCAAiC,EACjC,yBAA0B,EAC1B,2BAA4B,EAC5B,kBAAmB,EACnB,2BAA4B,EAC5B,sBAAuB,GAEvB,6BAA8B,GAC9B,iCAAkC,GAClC,4BAA6B,GAC7B,4BAA6B,GAE7B,4BAA6B,GAE7B,6BAA8B,GAI9B,iBAAkB,EACtB,EAEMC,GAAgB,CAElB,CAACD,EAAkB,cAAc,EAAG,wBACpC,CAACA,EAAkB,4BAA4B,EAAG,sCAClD,CAACA,EAAkB,wCAAwC,EAAG,2CAC9D,CAACA,EAAkB,uBAAuB,EAAG,iCAC7C,CAACA,EAAkB,+BAA+B,EAAG,uCACrD,CAACA,EAAkB,wBAAwB,EAAG,2BAC9C,CAACA,EAAkB,0BAA0B,EAAG,6BAChD,CAACA,EAAkB,iBAAiB,EAAG,oBACvC,CAACA,EAAkB,0BAA0B,EAAG,+BAChD,CAACA,EAAkB,qBAAqB,EAAG,wBAE3C,CAACA,EAAkB,4BAA4B,EAAG,4BAClD,CAACA,EAAkB,gCAAgC,EAAG,mCACtD,CAACA,EAAkB,2BAA2B,EAAG,8BACjD,CAACA,EAAkB,2BAA2B,EAAG,8CAEjD,CAACA,EAAkB,2BAA2B,EAAG,qCAEjD,CAACA,EAAkB,4BAA4B,EAAG,qCACtD,EACA,SAASE,EAAmBR,EAAMC,EAAKQ,EAAU,CAAA,EAAI,CACjD,KAAM,CAAE,OAAAC,EAAQ,SAAAC,EAAU,KAAAT,CAAS,EAAAO,EAC7BN,EAAO,QAAQ,IAAI,WAAa,aAChCC,IAAQO,GAAYJ,IAAeP,CAAI,GAAK,GAAI,GAAIE,GAAQ,CAAG,CAAA,EAC/DF,EACAY,EAAQ,IAAI,YAAY,OAAOT,CAAG,CAAC,EACzC,OAAAS,EAAM,KAAOZ,EACTC,IACAW,EAAM,SAAWX,GAErBW,EAAM,OAASF,EACRE,CACX,CAEA,SAASC,GAAeD,EAAO,CACrB,MAAAA,CACV,CAGA,MAAME,GAAc,0BACdC,GAAiBnB,GAAWkB,GAAY,KAAKlB,CAAM,EAEnDoB,EAAU,IACVC,GAAU,KACVC,EAAU;AAAA,EACVC,GAAU,SACVC,GAAU,SAChB,SAASC,GAAcC,EAAK,CACxB,MAAMC,EAAOD,EACb,IAAIE,EAAS,EACTC,EAAQ,EACRC,EAAU,EACVC,EAAc,EACZ,MAAAC,EAAUC,GAAUN,EAAKM,CAAK,IAAMZ,IAAWM,EAAKM,EAAQ,CAAC,IAAMX,EACnEY,EAAQD,GAAUN,EAAKM,CAAK,IAAMX,EAClCa,EAAQF,GAAUN,EAAKM,CAAK,IAAMT,GAClCY,EAAQH,GAAUN,EAAKM,CAAK,IAAMV,GAClCc,EAAaJ,GAAUD,EAAOC,CAAK,GAAKC,EAAKD,CAAK,GAAKE,EAAKF,CAAK,GAAKG,EAAKH,CAAK,EAChFA,EAAQ,IAAML,EACdlC,EAAO,IAAMmC,EACblC,EAAS,IAAMmC,EACfQ,EAAa,IAAMP,EACnBQ,EAAU3C,GAAWoC,EAAOpC,CAAM,GAAKuC,EAAKvC,CAAM,GAAKwC,EAAKxC,CAAM,EAAI0B,EAAUK,EAAK/B,CAAM,EAC3F4C,EAAc,IAAMD,EAAOX,CAAM,EACjCa,EAAc,IAAMF,EAAOX,EAASG,CAAW,EACrD,SAASW,GAAO,CACE,OAAAX,EAAA,EACVM,EAAUT,CAAM,IAChBC,IACUC,EAAA,GAEVE,EAAOJ,CAAM,GACbA,IAEJA,IACAE,IACOH,EAAKC,CAAM,CAAA,CAEtB,SAASe,GAAO,CACR,OAAAX,EAAOJ,EAASG,CAAW,GAC3BA,IAEJA,IACOJ,EAAKC,EAASG,CAAW,CAAA,CAEpC,SAASa,GAAQ,CACJhB,EAAA,EACDC,EAAA,EACEC,EAAA,EACIC,EAAA,CAAA,CAET,SAAAc,EAAUjD,EAAS,EAAG,CACbmC,EAAAnC,CAAA,CAElB,SAASkD,GAAa,CAClB,MAAMC,EAASnB,EAASG,EAExB,KAAOgB,IAAWnB,GACTc,EAAA,EAEKX,EAAA,CAAA,CAEX,MAAA,CACH,MAAAE,EACA,KAAAvC,EACA,OAAAC,EACA,WAAA2C,EACA,OAAAC,EACA,YAAAC,EACA,YAAAC,EACA,KAAAC,EACA,KAAAC,EACA,MAAAC,EACA,UAAAC,EACA,WAAAC,CACJ,CACJ,CAEA,MAAME,EAAM,OACNC,GAAM,IACNC,GAAoB,IACpBC,GAAiB,YACvB,SAASC,GAAgBpD,EAAQa,EAAU,GAAI,CACrC,MAAAwC,EAAWxC,EAAQ,WAAa,GAChCyC,EAAQ7B,GAAczB,CAAM,EAC5BuD,EAAgB,IAAMD,EAAM,MAAM,EAClCE,EAAkB,IAAM/D,GAAe6D,EAAM,KAAA,EAAQA,EAAM,OAAO,EAAGA,EAAM,OAAO,EAClFG,EAAWD,EAAgB,EAC3BE,EAAcH,EAAc,EAC5BI,EAAW,CACb,YAAa,GACb,OAAQD,EACR,SAAUD,EACV,OAAQA,EACR,SAAU,GACV,WAAYC,EACZ,aAAcD,EACd,WAAYA,EACZ,UAAW,EACX,SAAU,GACV,KAAM,EACV,EACMG,EAAU,IAAMD,EAChB,CAAE,QAAAE,GAAYhD,EACpB,SAASiD,EAAU1D,EAAM2D,EAAKnE,KAAWU,EAAM,CAC3C,MAAM0D,EAAMJ,EAAQ,EAGpB,GAFAG,EAAI,QAAUnE,EACdmE,EAAI,QAAUnE,EACViE,EAAS,CACT,MAAMxD,EAAMgD,EAAWxD,EAAemE,EAAI,SAAUD,CAAG,EAAI,KACrDE,EAAMrD,EAAmBR,EAAMC,EAAK,CACtC,OAAQ8C,GACR,KAAA7C,CAAA,CACH,EACDuD,EAAQI,CAAG,CAAA,CACf,CAEK,SAAAC,EAASN,EAASO,EAAMC,EAAO,CACpCR,EAAQ,OAASJ,EAAgB,EACjCI,EAAQ,YAAcO,EAChB,MAAAE,EAAQ,CAAE,KAAAF,CAAK,EACrB,OAAId,IACAgB,EAAM,IAAMxE,EAAe+D,EAAQ,SAAUA,EAAQ,MAAM,GAE3DQ,GAAS,OACTC,EAAM,MAAQD,GAEXC,CAAA,CAEL,MAAAC,EAAeV,GAAYM,EAASN,EAAS,EAAuB,EACjE,SAAAW,EAAIC,EAAMC,EAAI,CACf,OAAAD,EAAK,YAAY,IAAMC,GACvBD,EAAK,KAAK,EACHC,IAGPX,EAAUpD,EAAkB,eAAgB8C,EAAgB,EAAG,EAAGiB,CAAE,EAC7D,GACX,CAEJ,SAASC,EAAWF,EAAM,CACtB,IAAIG,EAAM,GACV,KAAOH,EAAK,gBAAkBpD,GAAWoD,EAAK,gBAAkBlD,GAC5DqD,GAAOH,EAAK,YAAY,EACxBA,EAAK,KAAK,EAEP,OAAAG,CAAA,CAEX,SAASC,EAAWJ,EAAM,CAChB,MAAAG,EAAMD,EAAWF,CAAI,EAC3B,OAAAA,EAAK,WAAW,EACTG,CAAA,CAEX,SAASE,EAAkBJ,EAAI,CAC3B,GAAIA,IAAOzB,EACA,MAAA,GAEL,MAAA8B,EAAKL,EAAG,WAAW,CAAC,EACjB,OAAAK,GAAM,IAAMA,GAAM,KACtBA,GAAM,IAAMA,GAAM,IACnBA,IAAO,EAAA,CAGf,SAASC,EAAcN,EAAI,CACvB,GAAIA,IAAOzB,EACA,MAAA,GAEL,MAAA8B,EAAKL,EAAG,WAAW,CAAC,EACnB,OAAAK,GAAM,IAAMA,GAAM,EAAA,CAEpB,SAAAE,EAAuBR,EAAMZ,EAAS,CACrC,KAAA,CAAE,YAAAqB,GAAgBrB,EACxB,GAAIqB,IAAgB,EACT,MAAA,GAEXP,EAAWF,CAAI,EACf,MAAMU,EAAML,EAAkBL,EAAK,YAAA,CAAa,EAChD,OAAAA,EAAK,UAAU,EACRU,CAAA,CAEF,SAAAC,EAAsBX,EAAMZ,EAAS,CACpC,KAAA,CAAE,YAAAqB,GAAgBrB,EACxB,GAAIqB,IAAgB,EACT,MAAA,GAEXP,EAAWF,CAAI,EACT,MAAAC,EAAKD,EAAK,gBAAkB,IAAMA,EAAK,KAAA,EAASA,EAAK,YAAY,EACjEU,EAAMH,EAAcN,CAAE,EAC5B,OAAAD,EAAK,UAAU,EACRU,CAAA,CAEF,SAAAE,EAAeZ,EAAMZ,EAAS,CAC7B,KAAA,CAAE,YAAAqB,GAAgBrB,EACxB,GAAIqB,IAAgB,EACT,MAAA,GAEXP,EAAWF,CAAI,EACT,MAAAU,EAAMV,EAAK,YAAA,IAAkBtB,GACnC,OAAAsB,EAAK,UAAU,EACRU,CAAA,CAEF,SAAAG,EAAiBb,EAAMZ,EAAS,CAC/B,KAAA,CAAE,YAAAqB,GAAgBrB,EACxB,GAAIqB,IAAgB,EACT,MAAA,GAEXP,EAAWF,CAAI,EACT,MAAAU,EAAMV,EAAK,YAAA,IAAkB,IACnC,OAAAA,EAAK,UAAU,EACRU,CAAA,CAEF,SAAAI,EAAsBd,EAAMZ,EAAS,CACpC,KAAA,CAAE,YAAAqB,GAAgBrB,EACxB,GAAIqB,IAAgB,EACT,MAAA,GAEXP,EAAWF,CAAI,EACf,MAAMU,EAAML,EAAkBL,EAAK,YAAA,CAAa,EAChD,OAAAA,EAAK,UAAU,EACRU,CAAA,CAEF,SAAAK,EAAuBf,EAAMZ,EAAS,CACrC,KAAA,CAAE,YAAAqB,GAAgBrB,EACxB,GAAI,EAAEqB,IAAgB,GAClBA,IAAgB,IACT,MAAA,GAEXP,EAAWF,CAAI,EACT,MAAAU,EAAMV,EAAK,YAAA,IAAkB,IACnC,OAAAA,EAAK,UAAU,EACRU,CAAA,CAEF,SAAAM,EAAmBhB,EAAMZ,EAAS,CACjC,KAAA,CAAE,YAAAqB,GAAgBrB,EACxB,GAAIqB,IAAgB,GACT,MAAA,GAEX,MAAMQ,EAAK,IAAM,CACP,MAAAhB,EAAKD,EAAK,YAAY,EAC5B,OAAIC,IAAO,IACAI,EAAkBL,EAAK,MAAM,EAE/BC,IAAO,KACZA,IAAO,KACPA,IAAO,KACPA,IAAO,KACPA,IAAO,KACPA,IAAOrD,GACP,CAACqD,EACM,GAEFA,IAAOnD,GACZkD,EAAK,KAAK,EACHiB,EAAG,GAIHC,EAAYlB,EAAM,EAAK,CAEtC,EACMU,EAAMO,EAAG,EACf,OAAAjB,EAAK,UAAU,EACRU,CAAA,CAEX,SAASS,EAAcnB,EAAM,CACzBE,EAAWF,CAAI,EACT,MAAAU,EAAMV,EAAK,YAAA,IAAkB,IACnC,OAAAA,EAAK,UAAU,EACRU,CAAA,CAEX,SAASU,EAAkBpB,EAAM,CACvB,MAAAqB,EAASnB,EAAWF,CAAI,EACxBU,EAAMV,EAAK,YAAA,IAAkB,KAC/BA,EAAK,SAAW,IACpB,OAAAA,EAAK,UAAU,EACR,CACH,SAAUU,EACV,SAAUW,EAAO,OAAS,CAC9B,CAAA,CAEK,SAAAH,EAAYlB,EAAM5B,EAAQ,GAAM,CACrC,MAAM6C,EAAK,CAACK,EAAW,GAAOC,EAAO,GAAIC,EAAe,KAAU,CACxD,MAAAvB,EAAKD,EAAK,YAAY,EAC5B,OAAIC,IAAO,IACAsB,IAAS,IAA8B,GAAQD,EAEjDrB,IAAO,KAAoC,CAACA,EAC1CsB,IAAS,IAA8B,GAAOD,EAEhDrB,IAAO,KACZD,EAAK,KAAK,EACHiB,EAAGK,EAAU,IAA6B,EAAI,GAEhDrB,IAAO,IACLsB,IAAS,KAA+BC,EACzC,GACA,EAAED,IAAS3E,GAAW2E,IAASzE,GAEhCmD,IAAOrD,GACZoD,EAAK,KAAK,EACHiB,EAAG,GAAMrE,EAAS4E,CAAY,GAEhCvB,IAAOnD,GACZkD,EAAK,KAAK,EACHiB,EAAG,GAAMnE,EAAS0E,CAAY,GAG9B,EAEf,EACMd,EAAMO,EAAG,EACf,OAAA7C,GAAS4B,EAAK,UAAU,EACjBU,CAAA,CAEF,SAAAe,EAASzB,EAAMiB,EAAI,CAClB,MAAAhB,EAAKD,EAAK,YAAY,EAC5B,OAAIC,IAAOzB,EACAA,EAEPyC,EAAGhB,CAAE,GACLD,EAAK,KAAK,EACHC,GAEJ,IAAA,CAEX,SAASyB,GAAazB,EAAI,CAChB,MAAAK,EAAKL,EAAG,WAAW,CAAC,EACjB,OAAAK,GAAM,IAAMA,GAAM,KACtBA,GAAM,IAAMA,GAAM,IAClBA,GAAM,IAAMA,GAAM,IACnBA,IAAO,IACPA,IAAO,EAAA,CAGf,SAASqB,GAAmB3B,EAAM,CACvB,OAAAyB,EAASzB,EAAM0B,EAAY,CAAA,CAEtC,SAASE,GAAkB3B,EAAI,CACrB,MAAAK,EAAKL,EAAG,WAAW,CAAC,EACjB,OAAAK,GAAM,IAAMA,GAAM,KACtBA,GAAM,IAAMA,GAAM,IAClBA,GAAM,IAAMA,GAAM,IACnBA,IAAO,IACPA,IAAO,IACPA,IAAO,EAAA,CAGf,SAASuB,GAAwB7B,EAAM,CAC5B,OAAAyB,EAASzB,EAAM4B,EAAiB,CAAA,CAE3C,SAASE,GAAQ7B,EAAI,CACX,MAAAK,EAAKL,EAAG,WAAW,CAAC,EACnB,OAAAK,GAAM,IAAMA,GAAM,EAAA,CAE7B,SAASyB,GAAU/B,EAAM,CACd,OAAAyB,EAASzB,EAAM8B,EAAO,CAAA,CAEjC,SAASE,GAAW/B,EAAI,CACd,MAAAK,EAAKL,EAAG,WAAW,CAAC,EACjB,OAAAK,GAAM,IAAMA,GAAM,IACtBA,GAAM,IAAMA,GAAM,IAClBA,GAAM,IAAMA,GAAM,GAAA,CAE3B,SAAS2B,GAAajC,EAAM,CACjB,OAAAyB,EAASzB,EAAMgC,EAAU,CAAA,CAEpC,SAASE,EAAUlC,EAAM,CACrB,IAAIC,EAAK,GACLkC,EAAM,GACF,KAAAlC,EAAK8B,GAAU/B,CAAI,GAChBmC,GAAAlC,EAEJ,OAAAkC,CAAA,CAEX,SAASC,GAAWpC,EAAM,CACtBI,EAAWJ,CAAI,EACT,MAAAC,EAAKD,EAAK,YAAY,EAC5B,OAAIC,IAAO,KACPX,EAAUpD,EAAkB,eAAgB8C,EAAgB,EAAG,EAAGiB,CAAE,EAExED,EAAK,KAAK,EACH,GAAA,CAEX,SAASqC,EAASrC,EAAM,CACpB,IAAIG,EAAM,GAEV,OAAa,CACH,MAAAF,EAAKD,EAAK,YAAY,EACxB,GAAAC,IAAO,KACPA,IAAO,KACPA,IAAO,KACPA,IAAO,KACP,CAACA,EACD,MACJ,GACSA,IAAO,IACR,GAAAiB,EAAYlB,CAAI,EACTG,GAAAF,EACPD,EAAK,KAAK,MAGV,eAGCC,IAAOrD,GAAWqD,IAAOnD,EAC1B,GAAAoE,EAAYlB,CAAI,EACTG,GAAAF,EACPD,EAAK,KAAK,MACd,IACSmB,EAAcnB,CAAI,EACvB,MAGOG,GAAAF,EACPD,EAAK,KAAK,OAIPG,GAAAF,EACPD,EAAK,KAAK,CACd,CAEG,OAAAG,CAAA,CAEX,SAASmC,GAAoBtC,EAAM,CAC/BI,EAAWJ,CAAI,EACf,IAAIC,EAAK,GACLsC,EAAO,GACH,KAAAtC,EAAK4B,GAAwB7B,CAAI,GAC7BuC,GAAAtC,EAER,OAAAD,EAAK,YAAY,IAAMxB,GACvBc,EAAUpD,EAAkB,2BAA4B8C,EAAgB,EAAG,CAAC,EAEzEuD,CAAA,CAEX,SAASC,GAAmBxC,EAAM,CAC9BI,EAAWJ,CAAI,EACf,IAAIJ,EAAQ,GACR,OAAAI,EAAK,YAAY,IAAM,KACvBA,EAAK,KAAK,EACDJ,GAAA,IAAIsC,EAAUlC,CAAI,CAAC,IAG5BJ,GAASsC,EAAUlC,CAAI,EAEvBA,EAAK,YAAY,IAAMxB,GACvBc,EAAUpD,EAAkB,2BAA4B8C,EAAgB,EAAG,CAAC,EAEzEY,CAAA,CAEX,SAAS6C,GAAUxC,EAAI,CACZ,OAAAA,IAAOvB,IAAqBuB,IAAOnD,CAAA,CAE9C,SAAS4F,GAAY1C,EAAM,CACvBI,EAAWJ,CAAI,EAEfD,EAAIC,EAAM,GAAI,EACd,IAAIC,EAAK,GACL0C,EAAU,GACd,KAAQ1C,EAAKwB,EAASzB,EAAMyC,EAAS,GAC7BxC,IAAO,KACP0C,GAAWC,GAAmB5C,CAAI,EAGvB2C,GAAA1C,EAGb,MAAA4C,EAAU7C,EAAK,YAAY,EAC7B,OAAA6C,IAAY/F,GAAW+F,IAAYrE,GACnCc,EAAUpD,EAAkB,yCAA0C8C,EAAgB,EAAG,CAAC,EAEtF6D,IAAY/F,IACZkD,EAAK,KAAK,EAEVD,EAAIC,EAAM,GAAI,GAEX2C,IAGX5C,EAAIC,EAAM,GAAI,EACP2C,EAAA,CAEX,SAASC,GAAmB5C,EAAM,CACxB,MAAAC,EAAKD,EAAK,YAAY,EAC5B,OAAQC,EAAI,CACR,IAAK,KACL,IAAK,IACD,OAAAD,EAAK,KAAK,EACH,KAAKC,CAAE,GAClB,IAAK,IACM,OAAA6C,GAA0B9C,EAAMC,EAAI,CAAC,EAChD,IAAK,IACM,OAAA6C,GAA0B9C,EAAMC,EAAI,CAAC,EAChD,QACI,OAAAX,EAAUpD,EAAkB,wBAAyB8C,EAAgB,EAAG,EAAGiB,CAAE,EACtE,EAAA,CACf,CAEK,SAAA6C,GAA0B9C,EAAM+C,EAASC,EAAQ,CACtDjD,EAAIC,EAAM+C,CAAO,EACjB,IAAIE,EAAW,GACf,QAASC,EAAI,EAAGA,EAAIF,EAAQE,IAAK,CACvB,MAAAjD,EAAKgC,GAAajC,CAAI,EAC5B,GAAI,CAACC,EAAI,CACLX,EAAUpD,EAAkB,gCAAiC8C,EAAgB,EAAG,EAAG,KAAK+D,CAAO,GAAGE,CAAQ,GAAGjD,EAAK,YAAA,CAAa,EAAE,EACjI,KAAA,CAEQiD,GAAAhD,CAAA,CAET,MAAA,KAAK8C,CAAO,GAAGE,CAAQ,EAAA,CAElC,SAASE,GAAoBlD,EAAI,CAC7B,OAAQA,IAAO,KACXA,IAAO,KACPA,IAAOrD,GACPqD,IAAOnD,CAAA,CAEf,SAASsG,GAAsBpD,EAAM,CACjCI,EAAWJ,CAAI,EACf,IAAIC,EAAK,GACLoD,EAAc,GAClB,KAAQpD,EAAKwB,EAASzB,EAAMmD,EAAmB,GAC5BE,GAAApD,EAEZ,OAAAoD,CAAA,CAEX,SAASC,GAAmBtD,EAAM,CAC9B,IAAIC,EAAK,GACLsC,EAAO,GACH,KAAAtC,EAAK0B,GAAmB3B,CAAI,GACxBuC,GAAAtC,EAEL,OAAAsC,CAAA,CAEX,SAASgB,GAAgBvD,EAAM,CACrB,MAAAiB,EAAMd,GAAQ,CACV,MAAAF,EAAKD,EAAK,YAAY,EAC5B,OAAIC,IAAO,KACPA,IAAO,KACPA,IAAO,KACPA,IAAO,KACPA,IAAO,KACPA,IAAO,KACP,CAACA,GAGIA,IAAOrD,EAFLuD,GAMAA,GAAAF,EACPD,EAAK,KAAK,EACHiB,EAAGd,CAAG,EAOrB,EACA,OAAOc,EAAG,EAAE,CAAA,CAEhB,SAASuC,EAAWxD,EAAM,CACtBI,EAAWJ,CAAI,EACf,MAAMyD,EAAS1D,EAAIC,EAAM,GAAyB,EAClD,OAAAI,EAAWJ,CAAI,EACRyD,CAAA,CAGF,SAAAC,EAAuB1D,EAAMZ,EAAS,CAC3C,IAAIS,EAAQ,KAEZ,OADWG,EAAK,YAAY,EAChB,CACR,IAAK,IACGZ,OAAAA,EAAQ,WAAa,GACrBE,EAAUpD,EAAkB,2BAA4B8C,EAAgB,EAAG,CAAC,EAEhFgB,EAAK,KAAK,EACFH,EAAAH,EAASN,EAAS,EAA8B,GAA8B,EACtFgB,EAAWJ,CAAI,EACfZ,EAAQ,YACDS,EACX,IAAK,IACD,OAAIT,EAAQ,UAAY,GACpBA,EAAQ,cAAgB,GACxBE,EAAUpD,EAAkB,kBAAmB8C,EAAgB,EAAG,CAAC,EAEvEgB,EAAK,KAAK,EACFH,EAAAH,EAASN,EAAS,EAA+B,GAA+B,EACxFA,EAAQ,YACRA,EAAQ,UAAY,GAAKgB,EAAWJ,CAAI,EACpCZ,EAAQ,UAAYA,EAAQ,YAAc,IAC1CA,EAAQ,SAAW,IAEhBS,EACX,IAAK,IACGT,OAAAA,EAAQ,UAAY,GACpBE,EAAUpD,EAAkB,2BAA4B8C,EAAgB,EAAG,CAAC,EAEhFa,EAAQ8D,EAAkB3D,EAAMZ,CAAO,GAAKU,EAAYV,CAAO,EAC/DA,EAAQ,UAAY,EACbS,EACX,QAAS,CACL,IAAI+D,EAAuB,GACvBC,EAAsB,GACtBC,EAAe,GACf,GAAA3C,EAAcnB,CAAI,EACdZ,OAAAA,EAAQ,UAAY,GACpBE,EAAUpD,EAAkB,2BAA4B8C,EAAgB,EAAG,CAAC,EAEhFa,EAAQH,EAASN,EAAS,EAAyBoE,EAAWxD,CAAI,CAAC,EAEnEZ,EAAQ,UAAY,EACpBA,EAAQ,SAAW,GACZS,EAEPT,GAAAA,EAAQ,UAAY,IACnBA,EAAQ,cAAgB,GACrBA,EAAQ,cAAgB,GACxBA,EAAQ,cAAgB,GAC5B,OAAAE,EAAUpD,EAAkB,2BAA4B8C,EAAgB,EAAG,CAAC,EAC5EI,EAAQ,UAAY,EACb2E,EAAU/D,EAAMZ,CAAO,EAElC,GAAKwE,EAAuBpD,EAAuBR,EAAMZ,CAAO,EAC5D,OAAAS,EAAQH,EAASN,EAAS,EAA0BkD,GAAoBtC,CAAI,CAAC,EAC7EI,EAAWJ,CAAI,EACRH,EAEX,GAAKgE,EAAsBlD,EAAsBX,EAAMZ,CAAO,EAC1D,OAAAS,EAAQH,EAASN,EAAS,EAAyBoD,GAAmBxC,CAAI,CAAC,EAC3EI,EAAWJ,CAAI,EACRH,EAEX,GAAKiE,EAAelD,EAAeZ,EAAMZ,CAAO,EAC5C,OAAAS,EAAQH,EAASN,EAAS,EAA4BsD,GAAY1C,CAAI,CAAC,EACvEI,EAAWJ,CAAI,EACRH,EAEX,GAAI,CAAC+D,GAAwB,CAACC,GAAuB,CAACC,EAElD,OAAAjE,EAAQH,EAASN,EAAS,GAAkCgE,GAAsBpD,CAAI,CAAC,EACvFV,EAAUpD,EAAkB,6BAA8B8C,EAAmB,EAAA,EAAGa,EAAM,KAAK,EAC3FO,EAAWJ,CAAI,EACRH,EAEX,KAAA,CACJ,CAEG,OAAAA,CAAA,CAGF,SAAA8D,EAAkB3D,EAAMZ,EAAS,CAChC,KAAA,CAAE,YAAAqB,GAAgBrB,EACxB,IAAIS,EAAQ,KACN,MAAAI,EAAKD,EAAK,YAAY,EAQ5B,QAPKS,IAAgB,GACjBA,IAAgB,GAChBA,IAAgB,IAChBA,IAAgB,MACfR,IAAOnD,GAAWmD,IAAOrD,IAC1B0C,EAAUpD,EAAkB,sBAAuB8C,EAAgB,EAAG,CAAC,EAEnEiB,EAAI,CACR,IAAK,IACD,OAAAD,EAAK,KAAK,EACFH,EAAAH,EAASN,EAAS,EAAgC,GAAgC,EAC1FA,EAAQ,SAAW,GACZS,EACX,IAAK,IACD,OAAAO,EAAWJ,CAAI,EACfA,EAAK,KAAK,EACHN,EAASN,EAAS,EAA8B,GAA8B,EACzF,IAAK,IACD,OAAAgB,EAAWJ,CAAI,EACfA,EAAK,KAAK,EACHN,EAASN,EAAS,GAAqC,GAAoC,EACtG,QACQ,OAAA+B,EAAcnB,CAAI,GAClBH,EAAQH,EAASN,EAAS,EAAyBoE,EAAWxD,CAAI,CAAC,EAEnEZ,EAAQ,UAAY,EACpBA,EAAQ,SAAW,GACZS,GAEPgB,EAAiBb,EAAMZ,CAAO,GAC9B2B,EAAuBf,EAAMZ,CAAO,GACpCgB,EAAWJ,CAAI,EACR2D,EAAkB3D,EAAMZ,CAAO,GAEtC0B,EAAsBd,EAAMZ,CAAO,GACnCgB,EAAWJ,CAAI,EACRN,EAASN,EAAS,GAAoCkE,GAAmBtD,CAAI,CAAC,GAErFgB,EAAmBhB,EAAMZ,CAAO,GAChCgB,EAAWJ,CAAI,EACXC,IAAO,IAEAyD,EAAuB1D,EAAMZ,CAAO,GAAKS,EAGzCH,EAASN,EAAS,GAA+BmE,GAAgBvD,CAAI,CAAC,IAGjFS,IAAgB,GAChBnB,EAAUpD,EAAkB,sBAAuB8C,EAAgB,EAAG,CAAC,EAE3EI,EAAQ,UAAY,EACpBA,EAAQ,SAAW,GACZ2E,EAAU/D,EAAMZ,CAAO,EAAA,CACtC,CAGK,SAAA2E,EAAU/D,EAAMZ,EAAS,CAC9B,IAAIS,EAAQ,CAAE,KAAM,EAAwB,EACxCT,GAAAA,EAAQ,UAAY,EACpB,OAAOsE,EAAuB1D,EAAMZ,CAAO,GAAKU,EAAYV,CAAO,EAEvE,GAAIA,EAAQ,SACR,OAAOuE,EAAkB3D,EAAMZ,CAAO,GAAKU,EAAYV,CAAO,EAGlE,OADWY,EAAK,YAAY,EAChB,CACR,IAAK,IACD,OAAO0D,EAAuB1D,EAAMZ,CAAO,GAAKU,EAAYV,CAAO,EACvE,IAAK,IACD,OAAAE,EAAUpD,EAAkB,yBAA0B8C,EAAgB,EAAG,CAAC,EAC1EgB,EAAK,KAAK,EACHN,EAASN,EAAS,EAA+B,GAA+B,EAC3F,IAAK,IACD,OAAOuE,EAAkB3D,EAAMZ,CAAO,GAAKU,EAAYV,CAAO,EAClE,QAAS,CACD,GAAA+B,EAAcnB,CAAI,EAClB,OAAAH,EAAQH,EAASN,EAAS,EAAyBoE,EAAWxD,CAAI,CAAC,EAEnEZ,EAAQ,UAAY,EACpBA,EAAQ,SAAW,GACZS,EAEX,KAAM,CAAE,SAAAmE,EAAU,SAAA1C,GAAaF,EAAkBpB,CAAI,EACrD,GAAIgE,EACA,OAAO1C,EACD5B,EAASN,EAAS,EAAyBiD,EAASrC,CAAI,CAAC,EACzDN,EAASN,EAAS,EAA2BgD,GAAWpC,CAAI,CAAC,EAEnE,GAAAkB,EAAYlB,CAAI,EAChB,OAAON,EAASN,EAAS,EAAyBiD,EAASrC,CAAI,CAAC,EAEpE,KAAA,CACJ,CAEG,OAAAH,CAAA,CAEX,SAASoE,IAAY,CACjB,KAAM,CAAE,YAAAxD,EAAa,OAAArF,EAAQ,SAAA8I,EAAU,OAAAC,CAAW,EAAAhF,EAO9C,OANJA,EAAS,SAAWsB,EACpBtB,EAAS,WAAa/D,EACtB+D,EAAS,aAAe+E,EACxB/E,EAAS,WAAagF,EACtBhF,EAAS,OAASJ,EAAc,EAChCI,EAAS,SAAWH,EAAgB,EAChCF,EAAM,YAAY,IAAMN,EACjBkB,EAASP,EAAU,EAAuB,EAE9C4E,EAAUjF,EAAOK,CAAQ,CAAA,CAE7B,MAAA,CACH,UAAA8E,GACA,cAAAlF,EACA,gBAAAC,EACA,QAAAI,CACJ,CACJ,CAEA,MAAMgF,GAAiB,SAEjBC,GAAgB,wDACtB,SAASC,GAAmBC,EAAOC,EAAYC,EAAY,CACvD,OAAQF,EAAO,CACX,IAAK,OACM,MAAA,KAEX,IAAK,MAEM,MAAA,IACX,QAAS,CACL,MAAMG,EAAY,SAASF,GAAcC,EAAY,EAAE,EACnD,OAAAC,GAAa,OAAUA,GAAa,MAC7B,OAAO,cAAcA,CAAS,EAIlC,GAAA,CACX,CAER,CACA,SAASC,GAAatI,EAAU,GAAI,CAC1B,MAAAwC,EAAWxC,EAAQ,WAAa,GAChC,CAAE,QAAAgD,EAAS,OAAAuF,CAAA,EAAWvI,EAC5B,SAASiD,EAAUuF,EAAUjJ,EAAMN,EAAOF,KAAWU,EAAM,CACjD,MAAAP,EAAMsJ,EAAS,gBAAgB,EAGrC,GAFAtJ,EAAI,QAAUH,EACdG,EAAI,QAAUH,EACViE,EAAS,CACT,MAAMxD,EAAMgD,EAAWxD,EAAeC,EAAOC,CAAG,EAAI,KAC9CkE,EAAMrD,EAAmBR,EAAMC,EAAK,CACtC,OAAQuI,GACR,KAAAtI,CAAA,CACH,EACDuD,EAAQI,CAAG,CAAA,CACf,CAEJ,SAASqF,EAASD,EAAUjJ,EAAMN,EAAOF,KAAWU,EAAM,CAChD,MAAAP,EAAMsJ,EAAS,gBAAgB,EAGrC,GAFAtJ,EAAI,QAAUH,EACdG,EAAI,QAAUH,EACVwJ,EAAQ,CACR,MAAM/I,EAAMgD,EAAWxD,EAAeC,EAAOC,CAAG,EAAI,KACpDqJ,EAAOjJ,GAAkBC,EAAMC,EAAKC,CAAI,CAAC,CAAA,CAC7C,CAEK,SAAAiJ,EAAUpF,EAAMvE,EAAQS,EAAK,CAC5B,MAAAmJ,EAAO,CAAE,KAAArF,CAAK,EACpB,OAAId,IACAmG,EAAK,MAAQ5J,EACb4J,EAAK,IAAM5J,EACX4J,EAAK,IAAM,CAAE,MAAOnJ,EAAK,IAAKA,CAAI,GAE/BmJ,CAAA,CAEX,SAASC,EAAQD,EAAM5J,EAAQmE,EAAKI,EAAM,CAIlCd,IACAmG,EAAK,IAAM5J,EACP4J,EAAK,MACLA,EAAK,IAAI,IAAMzF,GAEvB,CAEK,SAAA2F,EAAUC,EAAWvF,EAAO,CAC3B,MAAAR,EAAU+F,EAAU,QAAQ,EAC5BH,EAAOD,EAAU,EAAwB3F,EAAQ,OAAQA,EAAQ,QAAQ,EAC/E,OAAA4F,EAAK,MAAQpF,EACbqF,EAAQD,EAAMG,EAAU,cAAA,EAAiBA,EAAU,iBAAiB,EAC7DH,CAAA,CAEF,SAAAI,EAAUD,EAAW1H,EAAO,CAC3B,MAAA2B,EAAU+F,EAAU,QAAQ,EAC5B,CAAE,WAAY/J,EAAQ,aAAcS,CAAQ,EAAAuD,EAC5C4F,EAAOD,EAAU,EAAwB3J,EAAQS,CAAG,EACrD,OAAAmJ,EAAA,MAAQ,SAASvH,EAAO,EAAE,EAC/B0H,EAAU,UAAU,EACpBF,EAAQD,EAAMG,EAAU,cAAA,EAAiBA,EAAU,iBAAiB,EAC7DH,CAAA,CAEF,SAAAK,EAAWF,EAAWG,EAAKC,EAAQ,CAClC,MAAAnG,EAAU+F,EAAU,QAAQ,EAC5B,CAAE,WAAY/J,EAAQ,aAAcS,CAAQ,EAAAuD,EAC5C4F,EAAOD,EAAU,EAAyB3J,EAAQS,CAAG,EAC3D,OAAAmJ,EAAK,IAAMM,EACPC,IAAW,KACXP,EAAK,OAAS,IAElBG,EAAU,UAAU,EACpBF,EAAQD,EAAMG,EAAU,cAAA,EAAiBA,EAAU,iBAAiB,EAC7DH,CAAA,CAEF,SAAAQ,EAAaL,EAAWvF,EAAO,CAC9B,MAAAR,EAAU+F,EAAU,QAAQ,EAC5B,CAAE,WAAY/J,EAAQ,aAAcS,CAAQ,EAAAuD,EAC5C4F,EAAOD,EAAU,EAA2B3J,EAAQS,CAAG,EAC7D,OAAAmJ,EAAK,MAAQpF,EAAM,QAAQyE,GAAeC,EAAkB,EAC5Da,EAAU,UAAU,EACpBF,EAAQD,EAAMG,EAAU,cAAA,EAAiBA,EAAU,iBAAiB,EAC7DH,CAAA,CAEX,SAASS,EAAoBN,EAAW,CAC9B,MAAAtF,EAAQsF,EAAU,UAAU,EAC5B/F,EAAU+F,EAAU,QAAQ,EAC5B,CAAE,WAAY/J,EAAQ,aAAcS,CAAQ,EAAAuD,EAC5C4F,EAAOD,EAAU,EAAkC3J,EAAQS,CAAG,EAChE,OAAAgE,EAAM,OAAS,IAEfP,EAAU6F,EAAWjJ,EAAkB,iCAAkCkD,EAAQ,aAAc,CAAC,EAChG4F,EAAK,MAAQ,GACLC,EAAAD,EAAM5J,EAAQS,CAAG,EAClB,CACH,iBAAkBgE,EAClB,KAAAmF,CACJ,IAGAnF,EAAM,OAAS,MACLP,EAAA6F,EAAWjJ,EAAkB,4BAA6BkD,EAAQ,aAAc,EAAGsG,EAAgB7F,CAAK,CAAC,EAElHmF,EAAA,MAAQnF,EAAM,OAAS,GAC5BoF,EAAQD,EAAMG,EAAU,cAAA,EAAiBA,EAAU,iBAAiB,EAC7D,CACH,KAAAH,CACJ,EAAA,CAEK,SAAAW,EAAeR,EAAWvF,EAAO,CAChC,MAAAR,EAAU+F,EAAU,QAAQ,EAC5BH,EAAOD,EAAU,EAA6B3F,EAAQ,OAAQA,EAAQ,QAAQ,EACpF,OAAA4F,EAAK,MAAQpF,EACbqF,EAAQD,EAAMG,EAAU,cAAA,EAAiBA,EAAU,iBAAiB,EAC7DH,CAAA,CAEX,SAASY,EAAYT,EAAW,CACtB,MAAA/F,EAAU+F,EAAU,QAAQ,EAC5BU,EAAad,EAAU,EAA0B3F,EAAQ,OAAQA,EAAQ,QAAQ,EACnF,IAAAS,EAAQsF,EAAU,UAAU,EAC5B,GAAAtF,EAAM,OAAS,EAA8B,CACvC,MAAAiG,EAASL,EAAoBN,CAAS,EAC5CU,EAAW,SAAWC,EAAO,KACrBjG,EAAAiG,EAAO,kBAAoBX,EAAU,UAAU,CAAA,CAW3D,OARItF,EAAM,OAAS,IACLP,EAAA6F,EAAWjJ,EAAkB,4BAA6BkD,EAAQ,aAAc,EAAGsG,EAAgB7F,CAAK,CAAC,EAEvHA,EAAQsF,EAAU,UAAU,EAExBtF,EAAM,OAAS,IACfA,EAAQsF,EAAU,UAAU,GAExBtF,EAAM,KAAM,CAChB,IAAK,IACGA,EAAM,OAAS,MACLP,EAAA6F,EAAWjJ,EAAkB,4BAA6BkD,EAAQ,aAAc,EAAGsG,EAAgB7F,CAAK,CAAC,EAEvHgG,EAAW,IAAMF,EAAeR,EAAWtF,EAAM,OAAS,EAAE,EAC5D,MACJ,IAAK,GACGA,EAAM,OAAS,MACLP,EAAA6F,EAAWjJ,EAAkB,4BAA6BkD,EAAQ,aAAc,EAAGsG,EAAgB7F,CAAK,CAAC,EAEvHgG,EAAW,IAAMR,EAAWF,EAAWtF,EAAM,OAAS,EAAE,EACxD,MACJ,IAAK,GACGA,EAAM,OAAS,MACLP,EAAA6F,EAAWjJ,EAAkB,4BAA6BkD,EAAQ,aAAc,EAAGsG,EAAgB7F,CAAK,CAAC,EAEvHgG,EAAW,IAAMT,EAAUD,EAAWtF,EAAM,OAAS,EAAE,EACvD,MACJ,IAAK,GACGA,EAAM,OAAS,MACLP,EAAA6F,EAAWjJ,EAAkB,4BAA6BkD,EAAQ,aAAc,EAAGsG,EAAgB7F,CAAK,CAAC,EAEvHgG,EAAW,IAAML,EAAaL,EAAWtF,EAAM,OAAS,EAAE,EAC1D,MACJ,QAAS,CAELP,EAAU6F,EAAWjJ,EAAkB,4BAA6BkD,EAAQ,aAAc,CAAC,EACrF,MAAA2G,EAAcZ,EAAU,QAAQ,EAChCa,EAAqBjB,EAAU,EAA6BgB,EAAY,OAAQA,EAAY,QAAQ,EAC1G,OAAAC,EAAmB,MAAQ,GAC3Bf,EAAQe,EAAoBD,EAAY,OAAQA,EAAY,QAAQ,EACpEF,EAAW,IAAMG,EACjBf,EAAQY,EAAYE,EAAY,OAAQA,EAAY,QAAQ,EACrD,CACH,iBAAkBlG,EAClB,KAAMgG,CACV,CAAA,CACJ,CAEJ,OAAAZ,EAAQY,EAAYV,EAAU,cAAA,EAAiBA,EAAU,iBAAiB,EACnE,CACH,KAAMU,CACV,CAAA,CAEJ,SAASI,EAAad,EAAW,CACvB,MAAA/F,EAAU+F,EAAU,QAAQ,EAC5Be,EAAc9G,EAAQ,cAAgB,EACtC+F,EAAU,cAAA,EACV/F,EAAQ,OACR8E,EAAW9E,EAAQ,cAAgB,EACnCA,EAAQ,OACRA,EAAQ,SACR4F,EAAOD,EAAU,EAA2BmB,EAAahC,CAAQ,EACvEc,EAAK,MAAQ,CAAC,EACd,IAAIf,EAAY,KACZsB,EAAS,KACV,EAAA,CACO,MAAA1F,EAAQoE,GAAakB,EAAU,UAAU,EAE/C,OADYlB,EAAA,KACJpE,EAAM,KAAM,CAChB,IAAK,GACGA,EAAM,OAAS,MACLP,EAAA6F,EAAWjJ,EAAkB,4BAA6BkD,EAAQ,aAAc,EAAGsG,EAAgB7F,CAAK,CAAC,EAEvHmF,EAAK,MAAM,KAAKE,EAAUC,EAAWtF,EAAM,OAAS,EAAE,CAAC,EACvD,MACJ,IAAK,GACGA,EAAM,OAAS,MACLP,EAAA6F,EAAWjJ,EAAkB,4BAA6BkD,EAAQ,aAAc,EAAGsG,EAAgB7F,CAAK,CAAC,EAEvHmF,EAAK,MAAM,KAAKI,EAAUD,EAAWtF,EAAM,OAAS,EAAE,CAAC,EACvD,MACJ,IAAK,GACQ0F,EAAA,GACT,MACJ,IAAK,GACG1F,EAAM,OAAS,MACLP,EAAA6F,EAAWjJ,EAAkB,4BAA6BkD,EAAQ,aAAc,EAAGsG,EAAgB7F,CAAK,CAAC,EAElHmF,EAAA,MAAM,KAAKK,EAAWF,EAAWtF,EAAM,OAAS,GAAI,CAAC,CAAC0F,CAAM,CAAC,EAC9DA,IACST,EAAAK,EAAW1J,GAAiB,kBAAmB2D,EAAQ,aAAc,EAAGsG,EAAgB7F,CAAK,CAAC,EAC9F0F,EAAA,MAEb,MACJ,IAAK,GACG1F,EAAM,OAAS,MACLP,EAAA6F,EAAWjJ,EAAkB,4BAA6BkD,EAAQ,aAAc,EAAGsG,EAAgB7F,CAAK,CAAC,EAEvHmF,EAAK,MAAM,KAAKQ,EAAaL,EAAWtF,EAAM,OAAS,EAAE,CAAC,EAC1D,MACJ,IAAK,GAAgC,CAC3B,MAAAiG,EAASF,EAAYT,CAAS,EAC/BH,EAAA,MAAM,KAAKc,EAAO,IAAI,EAC3B7B,EAAY6B,EAAO,kBAAoB,KACvC,KAAA,CACJ,CAEC,OAAA1G,EAAQ,cAAgB,IAC7BA,EAAQ,cAAgB,GAE5B,MAAM+G,EAAY/G,EAAQ,cAAgB,EACpCA,EAAQ,WACR+F,EAAU,cAAc,EACxBhB,EAAS/E,EAAQ,cAAgB,EACjCA,EAAQ,WACR+F,EAAU,gBAAgB,EACxB,OAAAF,EAAAD,EAAMmB,EAAWhC,CAAM,EACxBa,CAAA,CAEX,SAASoB,EAAYjB,EAAW/J,EAAQS,EAAKwK,EAAS,CAC5C,MAAAjH,EAAU+F,EAAU,QAAQ,EAC9B,IAAAmB,EAAkBD,EAAQ,MAAM,SAAW,EAC/C,MAAMrB,EAAOD,EAAU,EAA0B3J,EAAQS,CAAG,EAC5DmJ,EAAK,MAAQ,CAAC,EACTA,EAAA,MAAM,KAAKqB,CAAO,EACpB,EAAA,CACO,MAAAtK,EAAMkK,EAAad,CAAS,EAC7BmB,IACiBA,EAAAvK,EAAI,MAAM,SAAW,GAEtCiJ,EAAA,MAAM,KAAKjJ,CAAG,CAAA,OACdqD,EAAQ,cAAgB,IACjC,OAAIkH,GACAhH,EAAU6F,EAAWjJ,EAAkB,6BAA8BL,EAAK,CAAC,EAE/EoJ,EAAQD,EAAMG,EAAU,cAAA,EAAiBA,EAAU,iBAAiB,EAC7DH,CAAA,CAEX,SAASuB,EAAcpB,EAAW,CACxB,MAAA/F,EAAU+F,EAAU,QAAQ,EAC5B,CAAE,OAAA/J,EAAQ,SAAA8I,CAAA,EAAa9E,EACvBiH,EAAUJ,EAAad,CAAS,EAClC,OAAA/F,EAAQ,cAAgB,GACjBiH,EAGAD,EAAYjB,EAAW/J,EAAQ8I,EAAUmC,CAAO,CAC3D,CAEJ,SAASG,EAAMhL,EAAQ,CACnB,MAAM2J,EAAYvG,GAAgBpD,EAAQiL,GAAO,CAAA,EAAIpK,CAAO,CAAC,EACvD+C,EAAU+F,EAAU,QAAQ,EAC5BH,EAAOD,EAAU,EAA4B3F,EAAQ,OAAQA,EAAQ,QAAQ,EAC/E,OAAAP,GAAYmG,EAAK,MACjBA,EAAK,IAAI,OAASxJ,GAEjBwJ,EAAA,KAAOuB,EAAcpB,CAAS,EAC/B9I,EAAQ,aACH2I,EAAA,SAAW3I,EAAQ,WAAWb,CAAM,GAGzC4D,EAAQ,cAAgB,IACdE,EAAA6F,EAAWjJ,EAAkB,4BAA6BkD,EAAQ,aAAc,EAAG5D,EAAO4D,EAAQ,MAAM,GAAK,EAAE,EAE7H6F,EAAQD,EAAMG,EAAU,cAAA,EAAiBA,EAAU,iBAAiB,EAC7DH,CAAA,CAEX,MAAO,CAAE,MAAAwB,CAAM,CACnB,CACA,SAASd,EAAgB7F,EAAO,CACxB,GAAAA,EAAM,OAAS,GACR,MAAA,MAEX,MAAM0C,GAAQ1C,EAAM,OAAS,IAAI,QAAQ,UAAW,KAAK,EAClD,OAAA0C,EAAK,OAAS,GAAKA,EAAK,MAAM,EAAG,CAAC,EAAI,IAAMA,CACvD,CAEA,SAASmE,GAAkBC,EAAKtK,EAAU,GACxC,CACE,MAAM8C,EAAW,CACb,IAAAwH,EACA,YAAa,GACjB,EAMO,MAAA,CAAE,QALO,IAAMxH,EAKJ,OAJFoD,IACHpD,EAAA,QAAQ,IAAIoD,CAAI,EAClBA,EAEc,CAC7B,CACA,SAASqE,GAAcC,EAAOC,EAAa,CACvC,QAAS5D,EAAI,EAAGA,EAAI2D,EAAM,OAAQ3D,IACjB6D,EAAAF,EAAM3D,CAAC,EAAG4D,CAAW,CAE1C,CACA,SAASC,EAAa/B,EAAM8B,EAAa,CAErC,OAAQ9B,EAAK,KAAM,CACf,IAAK,GACa4B,GAAA5B,EAAK,MAAO8B,CAAW,EACzBA,EAAA,OAAO,QAAmC,EACtD,MACJ,IAAK,GACaF,GAAA5B,EAAK,MAAO8B,CAAW,EACrC,MACJ,IAAK,GAA0B,CAEdC,EADE/B,EACK,IAAK8B,CAAW,EACxBA,EAAA,OAAO,QAAmC,EAC1CA,EAAA,OAAO,MAA+B,EAClD,KAAA,CAEJ,IAAK,GACWA,EAAA,OAAO,aAA6C,EACpDA,EAAA,OAAO,MAA+B,EAClD,MACJ,IAAK,GACWA,EAAA,OAAO,aAA6C,EACpDA,EAAA,OAAO,OAAiC,EACpD,KAAA,CAGZ,CAEA,SAASE,GAAUL,EAAKtK,EAAU,GAChC,CACQ,MAAAyK,EAAcJ,GAAkBC,CAAG,EAC7BG,EAAA,OAAO,WAAyC,EAE5DH,EAAI,MAAQI,EAAaJ,EAAI,KAAMG,CAAW,EAExC,MAAA1H,EAAU0H,EAAY,QAAQ,EACpCH,EAAI,QAAU,MAAM,KAAKvH,EAAQ,OAAO,CAC5C,CAEA,SAAS6H,GAASN,EAAK,CACnB,MAAMO,EAAOP,EAAI,KACb,OAAAO,EAAK,OAAS,EACdC,GAAoBD,CAAI,EAGxBA,EAAK,MAAM,QAAaE,GAAAD,GAAoBC,CAAC,CAAC,EAE3CT,CACX,CACA,SAASQ,GAAoBlL,EAAS,CAC9B,GAAAA,EAAQ,MAAM,SAAW,EAAG,CACtB,MAAAoL,EAAOpL,EAAQ,MAAM,CAAC,GACxBoL,EAAK,OAAS,GAA0BA,EAAK,OAAS,KACtDpL,EAAQ,OAASoL,EAAK,MACtB,OAAOA,EAAK,MAChB,KAEC,CACD,MAAMC,EAAS,CAAC,EAChB,QAASpE,EAAI,EAAGA,EAAIjH,EAAQ,MAAM,OAAQiH,IAAK,CACrC,MAAAmE,EAAOpL,EAAQ,MAAMiH,CAAC,EAIxB,GAHA,EAAEmE,EAAK,OAAS,GAA0BA,EAAK,OAAS,IAGxDA,EAAK,OAAS,KACd,MAEGC,EAAA,KAAKD,EAAK,KAAK,CAAA,CAE1B,GAAIC,EAAO,SAAWrL,EAAQ,MAAM,OAAQ,CAChCA,EAAA,OAASsL,GAAKD,CAAM,EAC5B,QAASpE,EAAI,EAAGA,EAAIjH,EAAQ,MAAM,OAAQiH,IAAK,CACrC,MAAAmE,EAAOpL,EAAQ,MAAMiH,CAAC,GACxBmE,EAAK,OAAS,GAA0BA,EAAK,OAAS,IACtD,OAAOA,EAAK,KAChB,CACJ,CACJ,CAER,CAEA,MAAMG,GAAiB,WAEvB,SAASC,EAAOzC,EAAM,CAElB,OADAA,EAAK,EAAIA,EAAK,KACNA,EAAK,KAAM,CACf,IAAK,GAA4B,CAC7B,MAAM0C,EAAW1C,EACjByC,EAAOC,EAAS,IAAI,EACpBA,EAAS,EAAIA,EAAS,KACtB,OAAOA,EAAS,KAChB,KAAA,CAEJ,IAAK,GAA0B,CAC3B,MAAMjE,EAASuB,EACT2C,EAAQlE,EAAO,MACrB,QAASP,EAAI,EAAGA,EAAIyE,EAAM,OAAQzE,IACvBuE,EAAAE,EAAMzE,CAAC,CAAC,EAEnBO,EAAO,EAAIkE,EACX,OAAOlE,EAAO,MACd,KAAA,CAEJ,IAAK,GAA2B,CAC5B,MAAMxH,EAAU+I,EACV4C,EAAQ3L,EAAQ,MACtB,QAASiH,EAAI,EAAGA,EAAI0E,EAAM,OAAQ1E,IACvBuE,EAAAG,EAAM1E,CAAC,CAAC,EAEnBjH,EAAQ,EAAI2L,EACZ,OAAO3L,EAAQ,MACXA,EAAQ,SACRA,EAAQ,EAAIA,EAAQ,OACpB,OAAOA,EAAQ,QAEnB,KAAA,CAEJ,IAAK,GACL,IAAK,GACL,IAAK,GACL,IAAK,GAA6B,CAC9B,MAAM4L,EAAY7C,EACd6C,EAAU,QACVA,EAAU,EAAIA,EAAU,MACxB,OAAOA,EAAU,OAErB,KAAA,CAEJ,IAAK,GAA0B,CAC3B,MAAMC,EAAS9C,EACfyC,EAAOK,EAAO,GAAG,EACjBA,EAAO,EAAIA,EAAO,IAClB,OAAOA,EAAO,IACVA,EAAO,WACPL,EAAOK,EAAO,QAAQ,EACtBA,EAAO,EAAIA,EAAO,SAClB,OAAOA,EAAO,UAElB,KAAA,CAEJ,IAAK,GAAwB,CACzB,MAAMC,EAAO/C,EACb+C,EAAK,EAAIA,EAAK,MACd,OAAOA,EAAK,MACZ,KAAA,CAEJ,IAAK,GAAyB,CAC1B,MAAMC,EAAQhD,EACdgD,EAAM,EAAIA,EAAM,IAChB,OAAOA,EAAM,IACb,KAAA,CAEJ,QACS,GAAA,QAAQ,IAAI,WAAa,aACpB,MAAA5L,EAAmBF,EAAkB,6BAA8B,KAAM,CAC3E,OAAQsL,GACR,KAAM,CAACxC,EAAK,IAAI,CAAA,CACnB,CACL,CAER,OAAOA,EAAK,IAChB,CAKA,MAAMiD,GAAe,SACrB,SAASC,GAAoBvB,EAAKtK,EAAS,CACvC,KAAM,CAAa,SAAA8L,EAAU,cAAAC,EAAe,WAAYC,CAAgB,EAAAhM,EAClEwC,EAAWxC,EAAQ,WAAa,GAChC8C,EAAW,CACb,SAAAgJ,EACA,KAAM,GACN,OAAQ,EACR,KAAM,EACN,OAAQ,EACR,IAAK,OACL,cAAAC,EACA,WAAYC,EACZ,YAAa,CACjB,EACIxJ,GAAY8H,EAAI,MACPxH,EAAA,OAASwH,EAAI,IAAI,QAE9B,MAAMvH,EAAU,IAAMD,EACb,SAAAmJ,EAAK1M,EAAMoJ,EAAM,CACtB7F,EAAS,MAAQvD,CAAA,CAEZ,SAAA2M,EAASC,EAAGC,EAAgB,GAAM,CACjC,MAAAC,EAAiBD,EAAgBL,EAAgB,GACvDE,EAAKD,EAAcK,EAAiB,KAAK,OAAOF,CAAC,EAAIE,CAAc,CAAA,CAE9D,SAAAC,EAAOC,EAAc,GAAM,CAC1B,MAAAC,EAAQ,EAAE1J,EAAS,YACzByJ,GAAeL,EAASM,CAAK,CAAA,CAExB,SAAAC,EAASF,EAAc,GAAM,CAC5B,MAAAC,EAAQ,EAAE1J,EAAS,YACzByJ,GAAeL,EAASM,CAAK,CAAA,CAEjC,SAASE,GAAU,CACfR,EAASpJ,EAAS,WAAW,CAAA,CAI1B,MAAA,CACH,QAAAC,EACA,KAAAkJ,EACA,OAAAK,EACA,SAAAG,EACA,QAAAC,EACA,OARYzD,GAAQ,IAAIA,CAAG,GAS3B,WARe,IAAMnG,EAAS,UASlC,CACJ,CACA,SAAS6J,GAAmBC,EAAWjE,EAAM,CACnC,KAAA,CAAE,OAAAkE,GAAWD,EACnBA,EAAU,KAAK,GAAGC,EAAO,QAAoC,CAAA,GAAG,EACnDC,EAAAF,EAAWjE,EAAK,GAAG,EAC5BA,EAAK,UACLiE,EAAU,KAAK,IAAI,EACNE,EAAAF,EAAWjE,EAAK,QAAQ,EACrCiE,EAAU,KAAK,SAAS,GAGxBA,EAAU,KAAK,oBAAoB,EAEvCA,EAAU,KAAK,GAAG,CACtB,CACA,SAASG,GAAoBH,EAAWjE,EAAM,CACpC,KAAA,CAAE,OAAAkE,EAAQ,WAAAG,CAAA,EAAeJ,EAC/BA,EAAU,KAAK,GAAGC,EAAO,WAA0C,CAAA,IAAI,EAC7DD,EAAA,OAAOI,GAAY,EACvB,MAAAC,EAAStE,EAAK,MAAM,OAC1B,QAAS9B,EAAI,EAAGA,EAAIoG,IAChBH,EAAaF,EAAWjE,EAAK,MAAM9B,CAAC,CAAC,EACjCA,IAAMoG,EAAS,GAFKpG,IAKxB+F,EAAU,KAAK,IAAI,EAEbA,EAAA,SAASI,GAAY,EAC/BJ,EAAU,KAAK,IAAI,CACvB,CACA,SAASM,GAAmBN,EAAWjE,EAAM,CACnC,KAAA,CAAE,OAAAkE,EAAQ,WAAAG,CAAA,EAAeJ,EAC3B,GAAAjE,EAAK,MAAM,OAAS,EAAG,CACvBiE,EAAU,KAAK,GAAGC,EAAO,QAAoC,CAAA,IAAI,EACvDD,EAAA,OAAOI,GAAY,EACvB,MAAAC,EAAStE,EAAK,MAAM,OAC1B,QAAS9B,EAAI,EAAGA,EAAIoG,IAChBH,EAAaF,EAAWjE,EAAK,MAAM9B,CAAC,CAAC,EACjCA,IAAMoG,EAAS,GAFKpG,IAKxB+F,EAAU,KAAK,IAAI,EAEbA,EAAA,SAASI,GAAY,EAC/BJ,EAAU,KAAK,IAAI,CAAA,CAE3B,CACA,SAASO,GAAiBP,EAAWjE,EAAM,CACnCA,EAAK,KACQmE,EAAAF,EAAWjE,EAAK,IAAI,EAGjCiE,EAAU,KAAK,MAAM,CAE7B,CACA,SAASE,EAAaF,EAAWjE,EAAM,CAC7B,KAAA,CAAE,OAAAkE,GAAWD,EACnB,OAAQjE,EAAK,KAAM,CACf,IAAK,GACDwE,GAAiBP,EAAWjE,CAAI,EAChC,MACJ,IAAK,GACDuE,GAAmBN,EAAWjE,CAAI,EAClC,MACJ,IAAK,GACDoE,GAAoBH,EAAWjE,CAAI,EACnC,MACJ,IAAK,GACDgE,GAAmBC,EAAWjE,CAAI,EAClC,MACJ,IAAK,GACDiE,EAAU,KAAK,KAAK,UAAUjE,EAAK,KAAK,EAAGA,CAAI,EAC/C,MACJ,IAAK,GACDiE,EAAU,KAAK,KAAK,UAAUjE,EAAK,KAAK,EAAGA,CAAI,EAC/C,MACJ,IAAK,GACDiE,EAAU,KAAK,GAAGC,EAAO,aAA8C,CAAA,IAAIA,EAAO,MAAgC,CAAA,IAAIlE,EAAK,KAAK,KAAMA,CAAI,EAC1I,MACJ,IAAK,GACDiE,EAAU,KAAK,GAAGC,EAAO,aAA8C,CAAA,IAAIA,EAAO,OAAA,CAAkC,IAAI,KAAK,UAAUlE,EAAK,GAAG,CAAC,KAAMA,CAAI,EAC1J,MACJ,IAAK,GACDiE,EAAU,KAAK,KAAK,UAAUjE,EAAK,KAAK,EAAGA,CAAI,EAC/C,MACJ,IAAK,GACDiE,EAAU,KAAK,KAAK,UAAUjE,EAAK,KAAK,EAAGA,CAAI,EAC/C,MACJ,QACS,GAAA,QAAQ,IAAI,WAAa,aACpB,MAAA5I,EAAmBF,EAAkB,4BAA6B,KAAM,CAC1E,OAAQ+L,GACR,KAAM,CAACjD,EAAK,IAAI,CAAA,CACnB,CACL,CAEZ,CAEA,MAAMyE,GAAW,CAAC9C,EAAKtK,EAAU,KAC5B,CACD,MAAMqN,EAAOC,GAAStN,EAAQ,IAAI,EAAIA,EAAQ,KAAO,SAC/C8L,EAAWwB,GAAStN,EAAQ,QAAQ,EACpCA,EAAQ,SACR,eACcA,EAAQ,UAEtB,MAAA+L,EAAgB/L,EAAQ,eAAiB,KACzCA,EAAQ,cACRqN,IAAS,QACL,IACA;AAAA,EACJL,EAAahN,EAAQ,WAAaA,EAAQ,WAAaqN,IAAS,QAChEE,EAAUjD,EAAI,SAAW,CAAC,EAC1BsC,EAAYf,GAAoBvB,EAAK,CAEvC,SAAAwB,EAEA,cAAAC,EACA,WAAAiB,CAAA,CACH,EACDJ,EAAU,KAAKS,IAAS,SAAW,2BAA6B,YAAY,EAC5ET,EAAU,OAAOI,CAAU,EACvBO,EAAQ,OAAS,IACjBX,EAAU,KAAK,WAAW1B,GAAKqC,EAAQ,IAASC,GAAA,GAAGA,CAAC,MAAMA,CAAC,EAAE,EAAG,IAAI,CAAC,UAAU,EAC/EZ,EAAU,QAAQ,GAEtBA,EAAU,KAAK,SAAS,EACxBE,EAAaF,EAAWtC,CAAG,EAC3BsC,EAAU,SAASI,CAAU,EAC7BJ,EAAU,KAAK,GAAG,EAClB,OAAOtC,EAAI,QACX,KAAM,CAAE,KAAA/K,EAAM,IAAAkO,GAAQb,EAAU,QAAQ,EACjC,MAAA,CACH,IAAAtC,EACA,KAAA/K,EACA,IAAKkO,EAAMA,EAAI,SAAW,MAC9B,CACJ,EAEA,SAASC,GAAYvO,EAAQa,EAAU,GAAI,CACvC,MAAM2N,EAAkBvD,GAAO,CAAC,EAAGpK,CAAO,EACpC4N,EAAM,CAAC,CAACD,EAAgB,IACxBE,EAAe,CAAC,CAACF,EAAgB,OACjCG,EAAiBH,EAAgB,UAAY,KAAO,GAAOA,EAAgB,SAG3ErD,EADShC,GAAaqF,CAAe,EACxB,MAAMxO,CAAM,EAC/B,OAAKyO,GAQDE,GAAkBlD,GAASN,CAAG,EAE9BuD,GAAgBzC,EAAOd,CAAG,EAEnB,CAAE,IAAAA,EAAK,KAAM,EAAG,IAVvBK,GAAUL,EAAKqD,CAAe,EAEvBP,GAAS9C,EAAKqD,CAAe,EAU5C","names":["createPosition","line","column","offset","createLocation","start","end","source","CompileWarnCodes","warnMessages","createCompileWarn","code","loc","args","msg","format","message","CompileErrorCodes","errorMessages","createCompileError","options","domain","messages","error","defaultOnError","RE_HTML_TAG","detectHtmlTag","CHAR_SP","CHAR_CR","CHAR_LF","CHAR_LS","CHAR_PS","createScanner","str","_buf","_index","_line","_column","_peekOffset","isCRLF","index","isLF","isPS","isLS","isLineEnd","peekOffset","charAt","currentChar","currentPeek","next","peek","reset","resetPeek","skipToPeek","target","EOF","DOT","LITERAL_DELIMITER","ERROR_DOMAIN$3","createTokenizer","location","_scnr","currentOffset","currentPosition","_initLoc","_initOffset","_context","context","onError","emitError","pos","ctx","err","getToken","type","value","token","getEndToken","eat","scnr","ch","peekSpaces","buf","skipSpaces","isIdentifierStart","cc","isNumberStart","isNamedIdentifierStart","currentType","ret","isListIdentifierStart","isLiteralStart","isLinkedDotStart","isLinkedModifierStart","isLinkedDelimiterStart","isLinkedReferStart","fn","isTextStart","isPluralStart","detectModuloStart","spaces","hasSpace","prev","detectModulo","takeChar","isIdentifier","takeIdentifierChar","isNamedIdentifier","takeNamedIdentifierChar","isDigit","takeDigit","isHexDigit","takeHexDigit","getDigits","num","readModulo","readText","readNamedIdentifier","name","readListIdentifier","isLiteral","readLiteral","literal","readEscapeSequence","current","readUnicodeEscapeSequence","unicode","digits","sequence","i","isInvalidIdentifier","readInvalidIdentifier","identifiers","readLinkedModifier","readLinkedRefer","readPlural","plural","readTokenInPlaceholder","readTokenInLinked","validNamedIdentifier","validListIdentifier","validLiteral","readToken","isModulo","nextToken","startLoc","endLoc","ERROR_DOMAIN$2","KNOWN_ESCAPES","fromEscapeSequence","match","codePoint4","codePoint6","codePoint","createParser","onWarn","tokenzer","emitWarn","startNode","node","endNode","parseText","tokenizer","parseList","parseNamed","key","modulo","parseLiteral","parseLinkedModifier","getTokenCaption","parseLinkedKey","parseLinked","linkedNode","parsed","nextContext","emptyLinkedKeyNode","parseMessage","startOffset","endOffset","parsePlural","msgNode","hasEmptyMessage","parseResource","parse","assign","createTransformer","ast","traverseNodes","nodes","transformer","traverseNode","transform","optimize","body","optimizeMessageNode","c","item","values","join","ERROR_DOMAIN$1","minify","resource","cases","items","valueNode","linked","list","named","ERROR_DOMAIN","createCodeGenerator","filename","breakLineCode","_needIndent","push","_newline","n","withBreakLine","_breakLineCode","indent","withNewLine","level","deindent","newline","generateLinkedNode","generator","helper","generateNode","generateMessageNode","needIndent","length","generatePluralNode","generateResource","generate","mode","isString","helpers","s","map","baseCompile","assignedOptions","jit","enalbeMinify","enambeOptimize"],"sources":["../../../../../../../node_modules/@intlify/message-compiler/dist/message-compiler.mjs"],"sourcesContent":["/*!\n  * message-compiler v9.14.4\n  * (c) 2025 kazuya kawaguchi\n  * Released under the MIT License.\n  */\nimport { format, assign, join, isString } from '@intlify/shared';\n\nconst LOCATION_STUB = {\n    start: { line: 1, column: 1, offset: 0 },\n    end: { line: 1, column: 1, offset: 0 }\n};\nfunction createPosition(line, column, offset) {\n    return { line, column, offset };\n}\nfunction createLocation(start, end, source) {\n    const loc = { start, end };\n    if (source != null) {\n        loc.source = source;\n    }\n    return loc;\n}\n\nconst CompileWarnCodes = {\n    USE_MODULO_SYNTAX: 1,\n    __EXTEND_POINT__: 2\n};\n/** @internal */\nconst warnMessages = {\n    [CompileWarnCodes.USE_MODULO_SYNTAX]: `Use modulo before '{{0}}'.`\n};\nfunction createCompileWarn(code, loc, ...args) {\n    const msg = (process.env.NODE_ENV !== 'production') ? format(warnMessages[code] || '', ...(args || [])) : code;\n    const message = { message: String(msg), code };\n    if (loc) {\n        message.location = loc;\n    }\n    return message;\n}\n\nconst CompileErrorCodes = {\n    // tokenizer error codes\n    EXPECTED_TOKEN: 1,\n    INVALID_TOKEN_IN_PLACEHOLDER: 2,\n    UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER: 3,\n    UNKNOWN_ESCAPE_SEQUENCE: 4,\n    INVALID_UNICODE_ESCAPE_SEQUENCE: 5,\n    UNBALANCED_CLOSING_BRACE: 6,\n    UNTERMINATED_CLOSING_BRACE: 7,\n    EMPTY_PLACEHOLDER: 8,\n    NOT_ALLOW_NEST_PLACEHOLDER: 9,\n    INVALID_LINKED_FORMAT: 10,\n    // parser error codes\n    MUST_HAVE_MESSAGES_IN_PLURAL: 11,\n    UNEXPECTED_EMPTY_LINKED_MODIFIER: 12,\n    UNEXPECTED_EMPTY_LINKED_KEY: 13,\n    UNEXPECTED_LEXICAL_ANALYSIS: 14,\n    // generator error codes\n    UNHANDLED_CODEGEN_NODE_TYPE: 15,\n    // minifier error codes\n    UNHANDLED_MINIFIER_NODE_TYPE: 16,\n    // Special value for higher-order compilers to pick up the last code\n    // to avoid collision of error codes. This should always be kept as the last\n    // item.\n    __EXTEND_POINT__: 17\n};\n/** @internal */\nconst errorMessages = {\n    // tokenizer error messages\n    [CompileErrorCodes.EXPECTED_TOKEN]: `Expected token: '{0}'`,\n    [CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER]: `Invalid token in placeholder: '{0}'`,\n    [CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER]: `Unterminated single quote in placeholder`,\n    [CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE]: `Unknown escape sequence: \\\\{0}`,\n    [CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE]: `Invalid unicode escape sequence: {0}`,\n    [CompileErrorCodes.UNBALANCED_CLOSING_BRACE]: `Unbalanced closing brace`,\n    [CompileErrorCodes.UNTERMINATED_CLOSING_BRACE]: `Unterminated closing brace`,\n    [CompileErrorCodes.EMPTY_PLACEHOLDER]: `Empty placeholder`,\n    [CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER]: `Not allowed nest placeholder`,\n    [CompileErrorCodes.INVALID_LINKED_FORMAT]: `Invalid linked format`,\n    // parser error messages\n    [CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL]: `Plural must have messages`,\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER]: `Unexpected empty linked modifier`,\n    [CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY]: `Unexpected empty linked key`,\n    [CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS]: `Unexpected lexical analysis in token: '{0}'`,\n    // generator error messages\n    [CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE]: `unhandled codegen node type: '{0}'`,\n    // minimizer error messages\n    [CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE]: `unhandled mimifier node type: '{0}'`\n};\nfunction createCompileError(code, loc, options = {}) {\n    const { domain, messages, args } = options;\n    const msg = (process.env.NODE_ENV !== 'production')\n        ? format((messages || errorMessages)[code] || '', ...(args || []))\n        : code;\n    const error = new SyntaxError(String(msg));\n    error.code = code;\n    if (loc) {\n        error.location = loc;\n    }\n    error.domain = domain;\n    return error;\n}\n/** @internal */\nfunction defaultOnError(error) {\n    throw error;\n}\n\n// eslint-disable-next-line no-useless-escape\nconst RE_HTML_TAG = /<\\/?[\\w\\s=\"/.':;#-\\/]+>/;\nconst detectHtmlTag = (source) => RE_HTML_TAG.test(source);\n\nconst CHAR_SP = ' ';\nconst CHAR_CR = '\\r';\nconst CHAR_LF = '\\n';\nconst CHAR_LS = String.fromCharCode(0x2028);\nconst CHAR_PS = String.fromCharCode(0x2029);\nfunction createScanner(str) {\n    const _buf = str;\n    let _index = 0;\n    let _line = 1;\n    let _column = 1;\n    let _peekOffset = 0;\n    const isCRLF = (index) => _buf[index] === CHAR_CR && _buf[index + 1] === CHAR_LF;\n    const isLF = (index) => _buf[index] === CHAR_LF;\n    const isPS = (index) => _buf[index] === CHAR_PS;\n    const isLS = (index) => _buf[index] === CHAR_LS;\n    const isLineEnd = (index) => isCRLF(index) || isLF(index) || isPS(index) || isLS(index);\n    const index = () => _index;\n    const line = () => _line;\n    const column = () => _column;\n    const peekOffset = () => _peekOffset;\n    const charAt = (offset) => isCRLF(offset) || isPS(offset) || isLS(offset) ? CHAR_LF : _buf[offset];\n    const currentChar = () => charAt(_index);\n    const currentPeek = () => charAt(_index + _peekOffset);\n    function next() {\n        _peekOffset = 0;\n        if (isLineEnd(_index)) {\n            _line++;\n            _column = 0;\n        }\n        if (isCRLF(_index)) {\n            _index++;\n        }\n        _index++;\n        _column++;\n        return _buf[_index];\n    }\n    function peek() {\n        if (isCRLF(_index + _peekOffset)) {\n            _peekOffset++;\n        }\n        _peekOffset++;\n        return _buf[_index + _peekOffset];\n    }\n    function reset() {\n        _index = 0;\n        _line = 1;\n        _column = 1;\n        _peekOffset = 0;\n    }\n    function resetPeek(offset = 0) {\n        _peekOffset = offset;\n    }\n    function skipToPeek() {\n        const target = _index + _peekOffset;\n        // eslint-disable-next-line no-unmodified-loop-condition\n        while (target !== _index) {\n            next();\n        }\n        _peekOffset = 0;\n    }\n    return {\n        index,\n        line,\n        column,\n        peekOffset,\n        charAt,\n        currentChar,\n        currentPeek,\n        next,\n        peek,\n        reset,\n        resetPeek,\n        skipToPeek\n    };\n}\n\nconst EOF = undefined;\nconst DOT = '.';\nconst LITERAL_DELIMITER = \"'\";\nconst ERROR_DOMAIN$3 = 'tokenizer';\nfunction createTokenizer(source, options = {}) {\n    const location = options.location !== false;\n    const _scnr = createScanner(source);\n    const currentOffset = () => _scnr.index();\n    const currentPosition = () => createPosition(_scnr.line(), _scnr.column(), _scnr.index());\n    const _initLoc = currentPosition();\n    const _initOffset = currentOffset();\n    const _context = {\n        currentType: 14 /* TokenTypes.EOF */,\n        offset: _initOffset,\n        startLoc: _initLoc,\n        endLoc: _initLoc,\n        lastType: 14 /* TokenTypes.EOF */,\n        lastOffset: _initOffset,\n        lastStartLoc: _initLoc,\n        lastEndLoc: _initLoc,\n        braceNest: 0,\n        inLinked: false,\n        text: ''\n    };\n    const context = () => _context;\n    const { onError } = options;\n    function emitError(code, pos, offset, ...args) {\n        const ctx = context();\n        pos.column += offset;\n        pos.offset += offset;\n        if (onError) {\n            const loc = location ? createLocation(ctx.startLoc, pos) : null;\n            const err = createCompileError(code, loc, {\n                domain: ERROR_DOMAIN$3,\n                args\n            });\n            onError(err);\n        }\n    }\n    function getToken(context, type, value) {\n        context.endLoc = currentPosition();\n        context.currentType = type;\n        const token = { type };\n        if (location) {\n            token.loc = createLocation(context.startLoc, context.endLoc);\n        }\n        if (value != null) {\n            token.value = value;\n        }\n        return token;\n    }\n    const getEndToken = (context) => getToken(context, 14 /* TokenTypes.EOF */);\n    function eat(scnr, ch) {\n        if (scnr.currentChar() === ch) {\n            scnr.next();\n            return ch;\n        }\n        else {\n            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n            return '';\n        }\n    }\n    function peekSpaces(scnr) {\n        let buf = '';\n        while (scnr.currentPeek() === CHAR_SP || scnr.currentPeek() === CHAR_LF) {\n            buf += scnr.currentPeek();\n            scnr.peek();\n        }\n        return buf;\n    }\n    function skipSpaces(scnr) {\n        const buf = peekSpaces(scnr);\n        scnr.skipToPeek();\n        return buf;\n    }\n    function isIdentifierStart(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        return ((cc >= 97 && cc <= 122) || // a-z\n            (cc >= 65 && cc <= 90) || // A-Z\n            cc === 95 // _\n        );\n    }\n    function isNumberStart(ch) {\n        if (ch === EOF) {\n            return false;\n        }\n        const cc = ch.charCodeAt(0);\n        return cc >= 48 && cc <= 57; // 0-9\n    }\n    function isNamedIdentifierStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = isIdentifierStart(scnr.currentPeek());\n        scnr.resetPeek();\n        return ret;\n    }\n    function isListIdentifierStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ch = scnr.currentPeek() === '-' ? scnr.peek() : scnr.currentPeek();\n        const ret = isNumberStart(ch);\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLiteralStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 2 /* TokenTypes.BraceLeft */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === LITERAL_DELIMITER;\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedDotStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 8 /* TokenTypes.LinkedAlias */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \".\" /* TokenChars.LinkedDot */;\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedModifierStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 9 /* TokenTypes.LinkedDot */) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = isIdentifierStart(scnr.currentPeek());\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedDelimiterStart(scnr, context) {\n        const { currentType } = context;\n        if (!(currentType === 8 /* TokenTypes.LinkedAlias */ ||\n            currentType === 12 /* TokenTypes.LinkedModifier */)) {\n            return false;\n        }\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \":\" /* TokenChars.LinkedDelimiter */;\n        scnr.resetPeek();\n        return ret;\n    }\n    function isLinkedReferStart(scnr, context) {\n        const { currentType } = context;\n        if (currentType !== 10 /* TokenTypes.LinkedDelimiter */) {\n            return false;\n        }\n        const fn = () => {\n            const ch = scnr.currentPeek();\n            if (ch === \"{\" /* TokenChars.BraceLeft */) {\n                return isIdentifierStart(scnr.peek());\n            }\n            else if (ch === \"@\" /* TokenChars.LinkedAlias */ ||\n                ch === \"%\" /* TokenChars.Modulo */ ||\n                ch === \"|\" /* TokenChars.Pipe */ ||\n                ch === \":\" /* TokenChars.LinkedDelimiter */ ||\n                ch === \".\" /* TokenChars.LinkedDot */ ||\n                ch === CHAR_SP ||\n                !ch) {\n                return false;\n            }\n            else if (ch === CHAR_LF) {\n                scnr.peek();\n                return fn();\n            }\n            else {\n                // other characters\n                return isTextStart(scnr, false);\n            }\n        };\n        const ret = fn();\n        scnr.resetPeek();\n        return ret;\n    }\n    function isPluralStart(scnr) {\n        peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \"|\" /* TokenChars.Pipe */;\n        scnr.resetPeek();\n        return ret;\n    }\n    function detectModuloStart(scnr) {\n        const spaces = peekSpaces(scnr);\n        const ret = scnr.currentPeek() === \"%\" /* TokenChars.Modulo */ &&\n            scnr.peek() === \"{\" /* TokenChars.BraceLeft */;\n        scnr.resetPeek();\n        return {\n            isModulo: ret,\n            hasSpace: spaces.length > 0\n        };\n    }\n    function isTextStart(scnr, reset = true) {\n        const fn = (hasSpace = false, prev = '', detectModulo = false) => {\n            const ch = scnr.currentPeek();\n            if (ch === \"{\" /* TokenChars.BraceLeft */) {\n                return prev === \"%\" /* TokenChars.Modulo */ ? false : hasSpace;\n            }\n            else if (ch === \"@\" /* TokenChars.LinkedAlias */ || !ch) {\n                return prev === \"%\" /* TokenChars.Modulo */ ? true : hasSpace;\n            }\n            else if (ch === \"%\" /* TokenChars.Modulo */) {\n                scnr.peek();\n                return fn(hasSpace, \"%\" /* TokenChars.Modulo */, true);\n            }\n            else if (ch === \"|\" /* TokenChars.Pipe */) {\n                return prev === \"%\" /* TokenChars.Modulo */ || detectModulo\n                    ? true\n                    : !(prev === CHAR_SP || prev === CHAR_LF);\n            }\n            else if (ch === CHAR_SP) {\n                scnr.peek();\n                return fn(true, CHAR_SP, detectModulo);\n            }\n            else if (ch === CHAR_LF) {\n                scnr.peek();\n                return fn(true, CHAR_LF, detectModulo);\n            }\n            else {\n                return true;\n            }\n        };\n        const ret = fn();\n        reset && scnr.resetPeek();\n        return ret;\n    }\n    function takeChar(scnr, fn) {\n        const ch = scnr.currentChar();\n        if (ch === EOF) {\n            return EOF;\n        }\n        if (fn(ch)) {\n            scnr.next();\n            return ch;\n        }\n        return null;\n    }\n    function isIdentifier(ch) {\n        const cc = ch.charCodeAt(0);\n        return ((cc >= 97 && cc <= 122) || // a-z\n            (cc >= 65 && cc <= 90) || // A-Z\n            (cc >= 48 && cc <= 57) || // 0-9\n            cc === 95 || // _\n            cc === 36 // $\n        );\n    }\n    function takeIdentifierChar(scnr) {\n        return takeChar(scnr, isIdentifier);\n    }\n    function isNamedIdentifier(ch) {\n        const cc = ch.charCodeAt(0);\n        return ((cc >= 97 && cc <= 122) || // a-z\n            (cc >= 65 && cc <= 90) || // A-Z\n            (cc >= 48 && cc <= 57) || // 0-9\n            cc === 95 || // _\n            cc === 36 || // $\n            cc === 45 // -\n        );\n    }\n    function takeNamedIdentifierChar(scnr) {\n        return takeChar(scnr, isNamedIdentifier);\n    }\n    function isDigit(ch) {\n        const cc = ch.charCodeAt(0);\n        return cc >= 48 && cc <= 57; // 0-9\n    }\n    function takeDigit(scnr) {\n        return takeChar(scnr, isDigit);\n    }\n    function isHexDigit(ch) {\n        const cc = ch.charCodeAt(0);\n        return ((cc >= 48 && cc <= 57) || // 0-9\n            (cc >= 65 && cc <= 70) || // A-F\n            (cc >= 97 && cc <= 102)); // a-f\n    }\n    function takeHexDigit(scnr) {\n        return takeChar(scnr, isHexDigit);\n    }\n    function getDigits(scnr) {\n        let ch = '';\n        let num = '';\n        while ((ch = takeDigit(scnr))) {\n            num += ch;\n        }\n        return num;\n    }\n    function readModulo(scnr) {\n        skipSpaces(scnr);\n        const ch = scnr.currentChar();\n        if (ch !== \"%\" /* TokenChars.Modulo */) {\n            emitError(CompileErrorCodes.EXPECTED_TOKEN, currentPosition(), 0, ch);\n        }\n        scnr.next();\n        return \"%\" /* TokenChars.Modulo */;\n    }\n    function readText(scnr) {\n        let buf = '';\n        // eslint-disable-next-line no-constant-condition\n        while (true) {\n            const ch = scnr.currentChar();\n            if (ch === \"{\" /* TokenChars.BraceLeft */ ||\n                ch === \"}\" /* TokenChars.BraceRight */ ||\n                ch === \"@\" /* TokenChars.LinkedAlias */ ||\n                ch === \"|\" /* TokenChars.Pipe */ ||\n                !ch) {\n                break;\n            }\n            else if (ch === \"%\" /* TokenChars.Modulo */) {\n                if (isTextStart(scnr)) {\n                    buf += ch;\n                    scnr.next();\n                }\n                else {\n                    break;\n                }\n            }\n            else if (ch === CHAR_SP || ch === CHAR_LF) {\n                if (isTextStart(scnr)) {\n                    buf += ch;\n                    scnr.next();\n                }\n                else if (isPluralStart(scnr)) {\n                    break;\n                }\n                else {\n                    buf += ch;\n                    scnr.next();\n                }\n            }\n            else {\n                buf += ch;\n                scnr.next();\n            }\n        }\n        return buf;\n    }\n    function readNamedIdentifier(scnr) {\n        skipSpaces(scnr);\n        let ch = '';\n        let name = '';\n        while ((ch = takeNamedIdentifierChar(scnr))) {\n            name += ch;\n        }\n        if (scnr.currentChar() === EOF) {\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n        }\n        return name;\n    }\n    function readListIdentifier(scnr) {\n        skipSpaces(scnr);\n        let value = '';\n        if (scnr.currentChar() === '-') {\n            scnr.next();\n            value += `-${getDigits(scnr)}`;\n        }\n        else {\n            value += getDigits(scnr);\n        }\n        if (scnr.currentChar() === EOF) {\n            emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n        }\n        return value;\n    }\n    function isLiteral(ch) {\n        return ch !== LITERAL_DELIMITER && ch !== CHAR_LF;\n    }\n    function readLiteral(scnr) {\n        skipSpaces(scnr);\n        // eslint-disable-next-line no-useless-escape\n        eat(scnr, `\\'`);\n        let ch = '';\n        let literal = '';\n        while ((ch = takeChar(scnr, isLiteral))) {\n            if (ch === '\\\\') {\n                literal += readEscapeSequence(scnr);\n            }\n            else {\n                literal += ch;\n            }\n        }\n        const current = scnr.currentChar();\n        if (current === CHAR_LF || current === EOF) {\n            emitError(CompileErrorCodes.UNTERMINATED_SINGLE_QUOTE_IN_PLACEHOLDER, currentPosition(), 0);\n            // TODO: Is it correct really?\n            if (current === CHAR_LF) {\n                scnr.next();\n                // eslint-disable-next-line no-useless-escape\n                eat(scnr, `\\'`);\n            }\n            return literal;\n        }\n        // eslint-disable-next-line no-useless-escape\n        eat(scnr, `\\'`);\n        return literal;\n    }\n    function readEscapeSequence(scnr) {\n        const ch = scnr.currentChar();\n        switch (ch) {\n            case '\\\\':\n            case `\\'`: // eslint-disable-line no-useless-escape\n                scnr.next();\n                return `\\\\${ch}`;\n            case 'u':\n                return readUnicodeEscapeSequence(scnr, ch, 4);\n            case 'U':\n                return readUnicodeEscapeSequence(scnr, ch, 6);\n            default:\n                emitError(CompileErrorCodes.UNKNOWN_ESCAPE_SEQUENCE, currentPosition(), 0, ch);\n                return '';\n        }\n    }\n    function readUnicodeEscapeSequence(scnr, unicode, digits) {\n        eat(scnr, unicode);\n        let sequence = '';\n        for (let i = 0; i < digits; i++) {\n            const ch = takeHexDigit(scnr);\n            if (!ch) {\n                emitError(CompileErrorCodes.INVALID_UNICODE_ESCAPE_SEQUENCE, currentPosition(), 0, `\\\\${unicode}${sequence}${scnr.currentChar()}`);\n                break;\n            }\n            sequence += ch;\n        }\n        return `\\\\${unicode}${sequence}`;\n    }\n    function isInvalidIdentifier(ch) {\n        return (ch !== \"{\" /* TokenChars.BraceLeft */ &&\n            ch !== \"}\" /* TokenChars.BraceRight */ &&\n            ch !== CHAR_SP &&\n            ch !== CHAR_LF);\n    }\n    function readInvalidIdentifier(scnr) {\n        skipSpaces(scnr);\n        let ch = '';\n        let identifiers = '';\n        while ((ch = takeChar(scnr, isInvalidIdentifier))) {\n            identifiers += ch;\n        }\n        return identifiers;\n    }\n    function readLinkedModifier(scnr) {\n        let ch = '';\n        let name = '';\n        while ((ch = takeIdentifierChar(scnr))) {\n            name += ch;\n        }\n        return name;\n    }\n    function readLinkedRefer(scnr) {\n        const fn = (buf) => {\n            const ch = scnr.currentChar();\n            if (ch === \"{\" /* TokenChars.BraceLeft */ ||\n                ch === \"%\" /* TokenChars.Modulo */ ||\n                ch === \"@\" /* TokenChars.LinkedAlias */ ||\n                ch === \"|\" /* TokenChars.Pipe */ ||\n                ch === \"(\" /* TokenChars.ParenLeft */ ||\n                ch === \")\" /* TokenChars.ParenRight */ ||\n                !ch) {\n                return buf;\n            }\n            else if (ch === CHAR_SP) {\n                return buf;\n            }\n            else if (ch === CHAR_LF || ch === DOT) {\n                buf += ch;\n                scnr.next();\n                return fn(buf);\n            }\n            else {\n                buf += ch;\n                scnr.next();\n                return fn(buf);\n            }\n        };\n        return fn('');\n    }\n    function readPlural(scnr) {\n        skipSpaces(scnr);\n        const plural = eat(scnr, \"|\" /* TokenChars.Pipe */);\n        skipSpaces(scnr);\n        return plural;\n    }\n    // TODO: We need refactoring of token parsing ...\n    function readTokenInPlaceholder(scnr, context) {\n        let token = null;\n        const ch = scnr.currentChar();\n        switch (ch) {\n            case \"{\" /* TokenChars.BraceLeft */:\n                if (context.braceNest >= 1) {\n                    emitError(CompileErrorCodes.NOT_ALLOW_NEST_PLACEHOLDER, currentPosition(), 0);\n                }\n                scnr.next();\n                token = getToken(context, 2 /* TokenTypes.BraceLeft */, \"{\" /* TokenChars.BraceLeft */);\n                skipSpaces(scnr);\n                context.braceNest++;\n                return token;\n            case \"}\" /* TokenChars.BraceRight */:\n                if (context.braceNest > 0 &&\n                    context.currentType === 2 /* TokenTypes.BraceLeft */) {\n                    emitError(CompileErrorCodes.EMPTY_PLACEHOLDER, currentPosition(), 0);\n                }\n                scnr.next();\n                token = getToken(context, 3 /* TokenTypes.BraceRight */, \"}\" /* TokenChars.BraceRight */);\n                context.braceNest--;\n                context.braceNest > 0 && skipSpaces(scnr);\n                if (context.inLinked && context.braceNest === 0) {\n                    context.inLinked = false;\n                }\n                return token;\n            case \"@\" /* TokenChars.LinkedAlias */:\n                if (context.braceNest > 0) {\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n                }\n                token = readTokenInLinked(scnr, context) || getEndToken(context);\n                context.braceNest = 0;\n                return token;\n            default: {\n                let validNamedIdentifier = true;\n                let validListIdentifier = true;\n                let validLiteral = true;\n                if (isPluralStart(scnr)) {\n                    if (context.braceNest > 0) {\n                        emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n                    }\n                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n                    // reset\n                    context.braceNest = 0;\n                    context.inLinked = false;\n                    return token;\n                }\n                if (context.braceNest > 0 &&\n                    (context.currentType === 5 /* TokenTypes.Named */ ||\n                        context.currentType === 6 /* TokenTypes.List */ ||\n                        context.currentType === 7 /* TokenTypes.Literal */)) {\n                    emitError(CompileErrorCodes.UNTERMINATED_CLOSING_BRACE, currentPosition(), 0);\n                    context.braceNest = 0;\n                    return readToken(scnr, context);\n                }\n                if ((validNamedIdentifier = isNamedIdentifierStart(scnr, context))) {\n                    token = getToken(context, 5 /* TokenTypes.Named */, readNamedIdentifier(scnr));\n                    skipSpaces(scnr);\n                    return token;\n                }\n                if ((validListIdentifier = isListIdentifierStart(scnr, context))) {\n                    token = getToken(context, 6 /* TokenTypes.List */, readListIdentifier(scnr));\n                    skipSpaces(scnr);\n                    return token;\n                }\n                if ((validLiteral = isLiteralStart(scnr, context))) {\n                    token = getToken(context, 7 /* TokenTypes.Literal */, readLiteral(scnr));\n                    skipSpaces(scnr);\n                    return token;\n                }\n                if (!validNamedIdentifier && !validListIdentifier && !validLiteral) {\n                    // TODO: we should be re-designed invalid cases, when we will extend message syntax near the future ...\n                    token = getToken(context, 13 /* TokenTypes.InvalidPlace */, readInvalidIdentifier(scnr));\n                    emitError(CompileErrorCodes.INVALID_TOKEN_IN_PLACEHOLDER, currentPosition(), 0, token.value);\n                    skipSpaces(scnr);\n                    return token;\n                }\n                break;\n            }\n        }\n        return token;\n    }\n    // TODO: We need refactoring of token parsing ...\n    function readTokenInLinked(scnr, context) {\n        const { currentType } = context;\n        let token = null;\n        const ch = scnr.currentChar();\n        if ((currentType === 8 /* TokenTypes.LinkedAlias */ ||\n            currentType === 9 /* TokenTypes.LinkedDot */ ||\n            currentType === 12 /* TokenTypes.LinkedModifier */ ||\n            currentType === 10 /* TokenTypes.LinkedDelimiter */) &&\n            (ch === CHAR_LF || ch === CHAR_SP)) {\n            emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n        }\n        switch (ch) {\n            case \"@\" /* TokenChars.LinkedAlias */:\n                scnr.next();\n                token = getToken(context, 8 /* TokenTypes.LinkedAlias */, \"@\" /* TokenChars.LinkedAlias */);\n                context.inLinked = true;\n                return token;\n            case \".\" /* TokenChars.LinkedDot */:\n                skipSpaces(scnr);\n                scnr.next();\n                return getToken(context, 9 /* TokenTypes.LinkedDot */, \".\" /* TokenChars.LinkedDot */);\n            case \":\" /* TokenChars.LinkedDelimiter */:\n                skipSpaces(scnr);\n                scnr.next();\n                return getToken(context, 10 /* TokenTypes.LinkedDelimiter */, \":\" /* TokenChars.LinkedDelimiter */);\n            default:\n                if (isPluralStart(scnr)) {\n                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n                    // reset\n                    context.braceNest = 0;\n                    context.inLinked = false;\n                    return token;\n                }\n                if (isLinkedDotStart(scnr, context) ||\n                    isLinkedDelimiterStart(scnr, context)) {\n                    skipSpaces(scnr);\n                    return readTokenInLinked(scnr, context);\n                }\n                if (isLinkedModifierStart(scnr, context)) {\n                    skipSpaces(scnr);\n                    return getToken(context, 12 /* TokenTypes.LinkedModifier */, readLinkedModifier(scnr));\n                }\n                if (isLinkedReferStart(scnr, context)) {\n                    skipSpaces(scnr);\n                    if (ch === \"{\" /* TokenChars.BraceLeft */) {\n                        // scan the placeholder\n                        return readTokenInPlaceholder(scnr, context) || token;\n                    }\n                    else {\n                        return getToken(context, 11 /* TokenTypes.LinkedKey */, readLinkedRefer(scnr));\n                    }\n                }\n                if (currentType === 8 /* TokenTypes.LinkedAlias */) {\n                    emitError(CompileErrorCodes.INVALID_LINKED_FORMAT, currentPosition(), 0);\n                }\n                context.braceNest = 0;\n                context.inLinked = false;\n                return readToken(scnr, context);\n        }\n    }\n    // TODO: We need refactoring of token parsing ...\n    function readToken(scnr, context) {\n        let token = { type: 14 /* TokenTypes.EOF */ };\n        if (context.braceNest > 0) {\n            return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n        }\n        if (context.inLinked) {\n            return readTokenInLinked(scnr, context) || getEndToken(context);\n        }\n        const ch = scnr.currentChar();\n        switch (ch) {\n            case \"{\" /* TokenChars.BraceLeft */:\n                return readTokenInPlaceholder(scnr, context) || getEndToken(context);\n            case \"}\" /* TokenChars.BraceRight */:\n                emitError(CompileErrorCodes.UNBALANCED_CLOSING_BRACE, currentPosition(), 0);\n                scnr.next();\n                return getToken(context, 3 /* TokenTypes.BraceRight */, \"}\" /* TokenChars.BraceRight */);\n            case \"@\" /* TokenChars.LinkedAlias */:\n                return readTokenInLinked(scnr, context) || getEndToken(context);\n            default: {\n                if (isPluralStart(scnr)) {\n                    token = getToken(context, 1 /* TokenTypes.Pipe */, readPlural(scnr));\n                    // reset\n                    context.braceNest = 0;\n                    context.inLinked = false;\n                    return token;\n                }\n                const { isModulo, hasSpace } = detectModuloStart(scnr);\n                if (isModulo) {\n                    return hasSpace\n                        ? getToken(context, 0 /* TokenTypes.Text */, readText(scnr))\n                        : getToken(context, 4 /* TokenTypes.Modulo */, readModulo(scnr));\n                }\n                if (isTextStart(scnr)) {\n                    return getToken(context, 0 /* TokenTypes.Text */, readText(scnr));\n                }\n                break;\n            }\n        }\n        return token;\n    }\n    function nextToken() {\n        const { currentType, offset, startLoc, endLoc } = _context;\n        _context.lastType = currentType;\n        _context.lastOffset = offset;\n        _context.lastStartLoc = startLoc;\n        _context.lastEndLoc = endLoc;\n        _context.offset = currentOffset();\n        _context.startLoc = currentPosition();\n        if (_scnr.currentChar() === EOF) {\n            return getToken(_context, 14 /* TokenTypes.EOF */);\n        }\n        return readToken(_scnr, _context);\n    }\n    return {\n        nextToken,\n        currentOffset,\n        currentPosition,\n        context\n    };\n}\n\nconst ERROR_DOMAIN$2 = 'parser';\n// Backslash backslash, backslash quote, uHHHH, UHHHHHH.\nconst KNOWN_ESCAPES = /(?:\\\\\\\\|\\\\'|\\\\u([0-9a-fA-F]{4})|\\\\U([0-9a-fA-F]{6}))/g;\nfunction fromEscapeSequence(match, codePoint4, codePoint6) {\n    switch (match) {\n        case `\\\\\\\\`:\n            return `\\\\`;\n        // eslint-disable-next-line no-useless-escape\n        case `\\\\\\'`:\n            // eslint-disable-next-line no-useless-escape\n            return `\\'`;\n        default: {\n            const codePoint = parseInt(codePoint4 || codePoint6, 16);\n            if (codePoint <= 0xd7ff || codePoint >= 0xe000) {\n                return String.fromCodePoint(codePoint);\n            }\n            // invalid ...\n            // Replace them with U+FFFD REPLACEMENT CHARACTER.\n            return '�';\n        }\n    }\n}\nfunction createParser(options = {}) {\n    const location = options.location !== false;\n    const { onError, onWarn } = options;\n    function emitError(tokenzer, code, start, offset, ...args) {\n        const end = tokenzer.currentPosition();\n        end.offset += offset;\n        end.column += offset;\n        if (onError) {\n            const loc = location ? createLocation(start, end) : null;\n            const err = createCompileError(code, loc, {\n                domain: ERROR_DOMAIN$2,\n                args\n            });\n            onError(err);\n        }\n    }\n    function emitWarn(tokenzer, code, start, offset, ...args) {\n        const end = tokenzer.currentPosition();\n        end.offset += offset;\n        end.column += offset;\n        if (onWarn) {\n            const loc = location ? createLocation(start, end) : null;\n            onWarn(createCompileWarn(code, loc, args));\n        }\n    }\n    function startNode(type, offset, loc) {\n        const node = { type };\n        if (location) {\n            node.start = offset;\n            node.end = offset;\n            node.loc = { start: loc, end: loc };\n        }\n        return node;\n    }\n    function endNode(node, offset, pos, type) {\n        if (type) {\n            node.type = type;\n        }\n        if (location) {\n            node.end = offset;\n            if (node.loc) {\n                node.loc.end = pos;\n            }\n        }\n    }\n    function parseText(tokenizer, value) {\n        const context = tokenizer.context();\n        const node = startNode(3 /* NodeTypes.Text */, context.offset, context.startLoc);\n        node.value = value;\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseList(tokenizer, index) {\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\n        const node = startNode(5 /* NodeTypes.List */, offset, loc);\n        node.index = parseInt(index, 10);\n        tokenizer.nextToken(); // skip brach right\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseNamed(tokenizer, key, modulo) {\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\n        const node = startNode(4 /* NodeTypes.Named */, offset, loc);\n        node.key = key;\n        if (modulo === true) {\n            node.modulo = true;\n        }\n        tokenizer.nextToken(); // skip brach right\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseLiteral(tokenizer, value) {\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get brace left loc\n        const node = startNode(9 /* NodeTypes.Literal */, offset, loc);\n        node.value = value.replace(KNOWN_ESCAPES, fromEscapeSequence);\n        tokenizer.nextToken(); // skip brach right\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseLinkedModifier(tokenizer) {\n        const token = tokenizer.nextToken();\n        const context = tokenizer.context();\n        const { lastOffset: offset, lastStartLoc: loc } = context; // get linked dot loc\n        const node = startNode(8 /* NodeTypes.LinkedModifier */, offset, loc);\n        if (token.type !== 12 /* TokenTypes.LinkedModifier */) {\n            // empty modifier\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_MODIFIER, context.lastStartLoc, 0);\n            node.value = '';\n            endNode(node, offset, loc);\n            return {\n                nextConsumeToken: token,\n                node\n            };\n        }\n        // check token\n        if (token.value == null) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        node.value = token.value || '';\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return {\n            node\n        };\n    }\n    function parseLinkedKey(tokenizer, value) {\n        const context = tokenizer.context();\n        const node = startNode(7 /* NodeTypes.LinkedKey */, context.offset, context.startLoc);\n        node.value = value;\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseLinked(tokenizer) {\n        const context = tokenizer.context();\n        const linkedNode = startNode(6 /* NodeTypes.Linked */, context.offset, context.startLoc);\n        let token = tokenizer.nextToken();\n        if (token.type === 9 /* TokenTypes.LinkedDot */) {\n            const parsed = parseLinkedModifier(tokenizer);\n            linkedNode.modifier = parsed.node;\n            token = parsed.nextConsumeToken || tokenizer.nextToken();\n        }\n        // asset check token\n        if (token.type !== 10 /* TokenTypes.LinkedDelimiter */) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n        }\n        token = tokenizer.nextToken();\n        // skip brace left\n        if (token.type === 2 /* TokenTypes.BraceLeft */) {\n            token = tokenizer.nextToken();\n        }\n        switch (token.type) {\n            case 11 /* TokenTypes.LinkedKey */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseLinkedKey(tokenizer, token.value || '');\n                break;\n            case 5 /* TokenTypes.Named */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseNamed(tokenizer, token.value || '');\n                break;\n            case 6 /* TokenTypes.List */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseList(tokenizer, token.value || '');\n                break;\n            case 7 /* TokenTypes.Literal */:\n                if (token.value == null) {\n                    emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                }\n                linkedNode.key = parseLiteral(tokenizer, token.value || '');\n                break;\n            default: {\n                // empty key\n                emitError(tokenizer, CompileErrorCodes.UNEXPECTED_EMPTY_LINKED_KEY, context.lastStartLoc, 0);\n                const nextContext = tokenizer.context();\n                const emptyLinkedKeyNode = startNode(7 /* NodeTypes.LinkedKey */, nextContext.offset, nextContext.startLoc);\n                emptyLinkedKeyNode.value = '';\n                endNode(emptyLinkedKeyNode, nextContext.offset, nextContext.startLoc);\n                linkedNode.key = emptyLinkedKeyNode;\n                endNode(linkedNode, nextContext.offset, nextContext.startLoc);\n                return {\n                    nextConsumeToken: token,\n                    node: linkedNode\n                };\n            }\n        }\n        endNode(linkedNode, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return {\n            node: linkedNode\n        };\n    }\n    function parseMessage(tokenizer) {\n        const context = tokenizer.context();\n        const startOffset = context.currentType === 1 /* TokenTypes.Pipe */\n            ? tokenizer.currentOffset()\n            : context.offset;\n        const startLoc = context.currentType === 1 /* TokenTypes.Pipe */\n            ? context.endLoc\n            : context.startLoc;\n        const node = startNode(2 /* NodeTypes.Message */, startOffset, startLoc);\n        node.items = [];\n        let nextToken = null;\n        let modulo = null;\n        do {\n            const token = nextToken || tokenizer.nextToken();\n            nextToken = null;\n            switch (token.type) {\n                case 0 /* TokenTypes.Text */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseText(tokenizer, token.value || ''));\n                    break;\n                case 6 /* TokenTypes.List */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseList(tokenizer, token.value || ''));\n                    break;\n                case 4 /* TokenTypes.Modulo */:\n                    modulo = true;\n                    break;\n                case 5 /* TokenTypes.Named */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseNamed(tokenizer, token.value || '', !!modulo));\n                    if (modulo) {\n                        emitWarn(tokenizer, CompileWarnCodes.USE_MODULO_SYNTAX, context.lastStartLoc, 0, getTokenCaption(token));\n                        modulo = null;\n                    }\n                    break;\n                case 7 /* TokenTypes.Literal */:\n                    if (token.value == null) {\n                        emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, getTokenCaption(token));\n                    }\n                    node.items.push(parseLiteral(tokenizer, token.value || ''));\n                    break;\n                case 8 /* TokenTypes.LinkedAlias */: {\n                    const parsed = parseLinked(tokenizer);\n                    node.items.push(parsed.node);\n                    nextToken = parsed.nextConsumeToken || null;\n                    break;\n                }\n            }\n        } while (context.currentType !== 14 /* TokenTypes.EOF */ &&\n            context.currentType !== 1 /* TokenTypes.Pipe */);\n        // adjust message node loc\n        const endOffset = context.currentType === 1 /* TokenTypes.Pipe */\n            ? context.lastOffset\n            : tokenizer.currentOffset();\n        const endLoc = context.currentType === 1 /* TokenTypes.Pipe */\n            ? context.lastEndLoc\n            : tokenizer.currentPosition();\n        endNode(node, endOffset, endLoc);\n        return node;\n    }\n    function parsePlural(tokenizer, offset, loc, msgNode) {\n        const context = tokenizer.context();\n        let hasEmptyMessage = msgNode.items.length === 0;\n        const node = startNode(1 /* NodeTypes.Plural */, offset, loc);\n        node.cases = [];\n        node.cases.push(msgNode);\n        do {\n            const msg = parseMessage(tokenizer);\n            if (!hasEmptyMessage) {\n                hasEmptyMessage = msg.items.length === 0;\n            }\n            node.cases.push(msg);\n        } while (context.currentType !== 14 /* TokenTypes.EOF */);\n        if (hasEmptyMessage) {\n            emitError(tokenizer, CompileErrorCodes.MUST_HAVE_MESSAGES_IN_PLURAL, loc, 0);\n        }\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    function parseResource(tokenizer) {\n        const context = tokenizer.context();\n        const { offset, startLoc } = context;\n        const msgNode = parseMessage(tokenizer);\n        if (context.currentType === 14 /* TokenTypes.EOF */) {\n            return msgNode;\n        }\n        else {\n            return parsePlural(tokenizer, offset, startLoc, msgNode);\n        }\n    }\n    function parse(source) {\n        const tokenizer = createTokenizer(source, assign({}, options));\n        const context = tokenizer.context();\n        const node = startNode(0 /* NodeTypes.Resource */, context.offset, context.startLoc);\n        if (location && node.loc) {\n            node.loc.source = source;\n        }\n        node.body = parseResource(tokenizer);\n        if (options.onCacheKey) {\n            node.cacheKey = options.onCacheKey(source);\n        }\n        // assert whether achieved to EOF\n        if (context.currentType !== 14 /* TokenTypes.EOF */) {\n            emitError(tokenizer, CompileErrorCodes.UNEXPECTED_LEXICAL_ANALYSIS, context.lastStartLoc, 0, source[context.offset] || '');\n        }\n        endNode(node, tokenizer.currentOffset(), tokenizer.currentPosition());\n        return node;\n    }\n    return { parse };\n}\nfunction getTokenCaption(token) {\n    if (token.type === 14 /* TokenTypes.EOF */) {\n        return 'EOF';\n    }\n    const name = (token.value || '').replace(/\\r?\\n/gu, '\\\\n');\n    return name.length > 10 ? name.slice(0, 9) + '…' : name;\n}\n\nfunction createTransformer(ast, options = {} // eslint-disable-line\n) {\n    const _context = {\n        ast,\n        helpers: new Set()\n    };\n    const context = () => _context;\n    const helper = (name) => {\n        _context.helpers.add(name);\n        return name;\n    };\n    return { context, helper };\n}\nfunction traverseNodes(nodes, transformer) {\n    for (let i = 0; i < nodes.length; i++) {\n        traverseNode(nodes[i], transformer);\n    }\n}\nfunction traverseNode(node, transformer) {\n    // TODO: if we need pre-hook of transform, should be implemented to here\n    switch (node.type) {\n        case 1 /* NodeTypes.Plural */:\n            traverseNodes(node.cases, transformer);\n            transformer.helper(\"plural\" /* HelperNameMap.PLURAL */);\n            break;\n        case 2 /* NodeTypes.Message */:\n            traverseNodes(node.items, transformer);\n            break;\n        case 6 /* NodeTypes.Linked */: {\n            const linked = node;\n            traverseNode(linked.key, transformer);\n            transformer.helper(\"linked\" /* HelperNameMap.LINKED */);\n            transformer.helper(\"type\" /* HelperNameMap.TYPE */);\n            break;\n        }\n        case 5 /* NodeTypes.List */:\n            transformer.helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */);\n            transformer.helper(\"list\" /* HelperNameMap.LIST */);\n            break;\n        case 4 /* NodeTypes.Named */:\n            transformer.helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */);\n            transformer.helper(\"named\" /* HelperNameMap.NAMED */);\n            break;\n    }\n    // TODO: if we need post-hook of transform, should be implemented to here\n}\n// transform AST\nfunction transform(ast, options = {} // eslint-disable-line\n) {\n    const transformer = createTransformer(ast);\n    transformer.helper(\"normalize\" /* HelperNameMap.NORMALIZE */);\n    // traverse\n    ast.body && traverseNode(ast.body, transformer);\n    // set meta information\n    const context = transformer.context();\n    ast.helpers = Array.from(context.helpers);\n}\n\nfunction optimize(ast) {\n    const body = ast.body;\n    if (body.type === 2 /* NodeTypes.Message */) {\n        optimizeMessageNode(body);\n    }\n    else {\n        body.cases.forEach(c => optimizeMessageNode(c));\n    }\n    return ast;\n}\nfunction optimizeMessageNode(message) {\n    if (message.items.length === 1) {\n        const item = message.items[0];\n        if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {\n            message.static = item.value;\n            delete item.value; // optimization for size\n        }\n    }\n    else {\n        const values = [];\n        for (let i = 0; i < message.items.length; i++) {\n            const item = message.items[i];\n            if (!(item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */)) {\n                break;\n            }\n            if (item.value == null) {\n                break;\n            }\n            values.push(item.value);\n        }\n        if (values.length === message.items.length) {\n            message.static = join(values);\n            for (let i = 0; i < message.items.length; i++) {\n                const item = message.items[i];\n                if (item.type === 3 /* NodeTypes.Text */ || item.type === 9 /* NodeTypes.Literal */) {\n                    delete item.value; // optimization for size\n                }\n            }\n        }\n    }\n}\n\nconst ERROR_DOMAIN$1 = 'minifier';\n/* eslint-disable @typescript-eslint/no-explicit-any */\nfunction minify(node) {\n    node.t = node.type;\n    switch (node.type) {\n        case 0 /* NodeTypes.Resource */: {\n            const resource = node;\n            minify(resource.body);\n            resource.b = resource.body;\n            delete resource.body;\n            break;\n        }\n        case 1 /* NodeTypes.Plural */: {\n            const plural = node;\n            const cases = plural.cases;\n            for (let i = 0; i < cases.length; i++) {\n                minify(cases[i]);\n            }\n            plural.c = cases;\n            delete plural.cases;\n            break;\n        }\n        case 2 /* NodeTypes.Message */: {\n            const message = node;\n            const items = message.items;\n            for (let i = 0; i < items.length; i++) {\n                minify(items[i]);\n            }\n            message.i = items;\n            delete message.items;\n            if (message.static) {\n                message.s = message.static;\n                delete message.static;\n            }\n            break;\n        }\n        case 3 /* NodeTypes.Text */:\n        case 9 /* NodeTypes.Literal */:\n        case 8 /* NodeTypes.LinkedModifier */:\n        case 7 /* NodeTypes.LinkedKey */: {\n            const valueNode = node;\n            if (valueNode.value) {\n                valueNode.v = valueNode.value;\n                delete valueNode.value;\n            }\n            break;\n        }\n        case 6 /* NodeTypes.Linked */: {\n            const linked = node;\n            minify(linked.key);\n            linked.k = linked.key;\n            delete linked.key;\n            if (linked.modifier) {\n                minify(linked.modifier);\n                linked.m = linked.modifier;\n                delete linked.modifier;\n            }\n            break;\n        }\n        case 5 /* NodeTypes.List */: {\n            const list = node;\n            list.i = list.index;\n            delete list.index;\n            break;\n        }\n        case 4 /* NodeTypes.Named */: {\n            const named = node;\n            named.k = named.key;\n            delete named.key;\n            break;\n        }\n        default:\n            if ((process.env.NODE_ENV !== 'production')) {\n                throw createCompileError(CompileErrorCodes.UNHANDLED_MINIFIER_NODE_TYPE, null, {\n                    domain: ERROR_DOMAIN$1,\n                    args: [node.type]\n                });\n            }\n    }\n    delete node.type;\n}\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference types=\"source-map-js\" />\nconst ERROR_DOMAIN = 'parser';\nfunction createCodeGenerator(ast, options) {\n    const { sourceMap, filename, breakLineCode, needIndent: _needIndent } = options;\n    const location = options.location !== false;\n    const _context = {\n        filename,\n        code: '',\n        column: 1,\n        line: 1,\n        offset: 0,\n        map: undefined,\n        breakLineCode,\n        needIndent: _needIndent,\n        indentLevel: 0\n    };\n    if (location && ast.loc) {\n        _context.source = ast.loc.source;\n    }\n    const context = () => _context;\n    function push(code, node) {\n        _context.code += code;\n    }\n    function _newline(n, withBreakLine = true) {\n        const _breakLineCode = withBreakLine ? breakLineCode : '';\n        push(_needIndent ? _breakLineCode + `  `.repeat(n) : _breakLineCode);\n    }\n    function indent(withNewLine = true) {\n        const level = ++_context.indentLevel;\n        withNewLine && _newline(level);\n    }\n    function deindent(withNewLine = true) {\n        const level = --_context.indentLevel;\n        withNewLine && _newline(level);\n    }\n    function newline() {\n        _newline(_context.indentLevel);\n    }\n    const helper = (key) => `_${key}`;\n    const needIndent = () => _context.needIndent;\n    return {\n        context,\n        push,\n        indent,\n        deindent,\n        newline,\n        helper,\n        needIndent\n    };\n}\nfunction generateLinkedNode(generator, node) {\n    const { helper } = generator;\n    generator.push(`${helper(\"linked\" /* HelperNameMap.LINKED */)}(`);\n    generateNode(generator, node.key);\n    if (node.modifier) {\n        generator.push(`, `);\n        generateNode(generator, node.modifier);\n        generator.push(`, _type`);\n    }\n    else {\n        generator.push(`, undefined, _type`);\n    }\n    generator.push(`)`);\n}\nfunction generateMessageNode(generator, node) {\n    const { helper, needIndent } = generator;\n    generator.push(`${helper(\"normalize\" /* HelperNameMap.NORMALIZE */)}([`);\n    generator.indent(needIndent());\n    const length = node.items.length;\n    for (let i = 0; i < length; i++) {\n        generateNode(generator, node.items[i]);\n        if (i === length - 1) {\n            break;\n        }\n        generator.push(', ');\n    }\n    generator.deindent(needIndent());\n    generator.push('])');\n}\nfunction generatePluralNode(generator, node) {\n    const { helper, needIndent } = generator;\n    if (node.cases.length > 1) {\n        generator.push(`${helper(\"plural\" /* HelperNameMap.PLURAL */)}([`);\n        generator.indent(needIndent());\n        const length = node.cases.length;\n        for (let i = 0; i < length; i++) {\n            generateNode(generator, node.cases[i]);\n            if (i === length - 1) {\n                break;\n            }\n            generator.push(', ');\n        }\n        generator.deindent(needIndent());\n        generator.push(`])`);\n    }\n}\nfunction generateResource(generator, node) {\n    if (node.body) {\n        generateNode(generator, node.body);\n    }\n    else {\n        generator.push('null');\n    }\n}\nfunction generateNode(generator, node) {\n    const { helper } = generator;\n    switch (node.type) {\n        case 0 /* NodeTypes.Resource */:\n            generateResource(generator, node);\n            break;\n        case 1 /* NodeTypes.Plural */:\n            generatePluralNode(generator, node);\n            break;\n        case 2 /* NodeTypes.Message */:\n            generateMessageNode(generator, node);\n            break;\n        case 6 /* NodeTypes.Linked */:\n            generateLinkedNode(generator, node);\n            break;\n        case 8 /* NodeTypes.LinkedModifier */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        case 7 /* NodeTypes.LinkedKey */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        case 5 /* NodeTypes.List */:\n            generator.push(`${helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */)}(${helper(\"list\" /* HelperNameMap.LIST */)}(${node.index}))`, node);\n            break;\n        case 4 /* NodeTypes.Named */:\n            generator.push(`${helper(\"interpolate\" /* HelperNameMap.INTERPOLATE */)}(${helper(\"named\" /* HelperNameMap.NAMED */)}(${JSON.stringify(node.key)}))`, node);\n            break;\n        case 9 /* NodeTypes.Literal */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        case 3 /* NodeTypes.Text */:\n            generator.push(JSON.stringify(node.value), node);\n            break;\n        default:\n            if ((process.env.NODE_ENV !== 'production')) {\n                throw createCompileError(CompileErrorCodes.UNHANDLED_CODEGEN_NODE_TYPE, null, {\n                    domain: ERROR_DOMAIN,\n                    args: [node.type]\n                });\n            }\n    }\n}\n// generate code from AST\nconst generate = (ast, options = {} // eslint-disable-line\n) => {\n    const mode = isString(options.mode) ? options.mode : 'normal';\n    const filename = isString(options.filename)\n        ? options.filename\n        : 'message.intl';\n    const sourceMap = !!options.sourceMap;\n    // prettier-ignore\n    const breakLineCode = options.breakLineCode != null\n        ? options.breakLineCode\n        : mode === 'arrow'\n            ? ';'\n            : '\\n';\n    const needIndent = options.needIndent ? options.needIndent : mode !== 'arrow';\n    const helpers = ast.helpers || [];\n    const generator = createCodeGenerator(ast, {\n        mode,\n        filename,\n        sourceMap,\n        breakLineCode,\n        needIndent\n    });\n    generator.push(mode === 'normal' ? `function __msg__ (ctx) {` : `(ctx) => {`);\n    generator.indent(needIndent);\n    if (helpers.length > 0) {\n        generator.push(`const { ${join(helpers.map(s => `${s}: _${s}`), ', ')} } = ctx`);\n        generator.newline();\n    }\n    generator.push(`return `);\n    generateNode(generator, ast);\n    generator.deindent(needIndent);\n    generator.push(`}`);\n    delete ast.helpers;\n    const { code, map } = generator.context();\n    return {\n        ast,\n        code,\n        map: map ? map.toJSON() : undefined // eslint-disable-line @typescript-eslint/no-explicit-any\n    };\n};\n\nfunction baseCompile(source, options = {}) {\n    const assignedOptions = assign({}, options);\n    const jit = !!assignedOptions.jit;\n    const enalbeMinify = !!assignedOptions.minify;\n    const enambeOptimize = assignedOptions.optimize == null ? true : assignedOptions.optimize;\n    // parse source codes\n    const parser = createParser(assignedOptions);\n    const ast = parser.parse(source);\n    if (!jit) {\n        // transform ASTs\n        transform(ast, assignedOptions);\n        // generate javascript codes\n        return generate(ast, assignedOptions);\n    }\n    else {\n        // optimize ASTs\n        enambeOptimize && optimize(ast);\n        // minimize ASTs\n        enalbeMinify && minify(ast);\n        // In JIT mode, no ast transform, no code generation.\n        return { ast, code: '' };\n    }\n}\n\nexport { CompileErrorCodes, CompileWarnCodes, ERROR_DOMAIN$2 as ERROR_DOMAIN, LOCATION_STUB, baseCompile, createCompileError, createCompileWarn, createLocation, createParser, createPosition, defaultOnError, detectHtmlTag, errorMessages, warnMessages };\n"],"version":3}