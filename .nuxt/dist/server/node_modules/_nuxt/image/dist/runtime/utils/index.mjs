function u(t){return e=>e?t[e]||e:t.missingValue}function a({formatter:t,keyMap:e,joinWith:o="/",valueMap:n}={}){t||(t=(r,c)=>`${r}=${c}`),e&&typeof e!="function"&&(e=u(e));const s=n||{};return Object.keys(s).forEach(r=>{typeof s[r]!="function"&&(s[r]=u(s[r]))}),(r={})=>Object.entries(r).filter(([i,f])=>typeof f<"u").map(([i,f])=>{const p=s[i];return typeof p=="function"&&(f=p(r[i])),i=typeof e=="function"?e(i):i,t(i,f)}).join(o)}function l(t=""){if(typeof t=="number")return t;if(typeof t=="string"&&t.replace("px","").match(/^\d+$/g))return Number.parseInt(t,10)}function d(t=""){if(t===void 0||!t.length)return[];const e=new Set;for(const o of t.split(" ")){const n=Number.parseInt(o.replace("x",""));n&&e.add(n)}return Array.from(e)}function g(t){if(t.length===0)throw new Error("`densities` must not be empty, configure to `1` to render regular size only (DPR 1.0)")}function m(t){const e={};if(typeof t=="string")for(const o of t.split(/[\s,]+/).filter(n=>n)){const n=o.split(":");n.length!==2?e["1px"]=n[0].trim():e[n[0].trim()]=n[1].trim()}else Object.assign(e,t);return e}export{g as checkDensities,u as createMapper,a as createOperationsGenerator,d as parseDensities,l as parseSize,m as parseSizes};
//# sourceMappingURL=index.mjs.map
