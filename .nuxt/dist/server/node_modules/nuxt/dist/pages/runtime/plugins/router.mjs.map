{"version":3,"file":"router.mjs","sources":["../../../../../../../../../node_modules/nuxt/dist/pages/runtime/plugins/router.js"],"sourcesContent":["import { isReadonly, reactive, shallowReactive, shallowRef } from \"vue\";\nimport { START_LOCATION, createMemoryHistory, createRouter, createWebHashHistory, createWebHistory } from \"vue-router\";\nimport { createError } from \"h3\";\nimport { isEqual, withoutBase } from \"ufo\";\nimport { toArray } from \"../utils.js\";\nimport { getRouteRules } from \"#app/composables/manifest\";\nimport { defineNuxtPlugin, useRuntimeConfig } from \"#app/nuxt\";\nimport { clearError, isNuxtError, showError, useError } from \"#app/composables/error\";\nimport { navigateTo } from \"#app/composables/router\";\nimport { appManifest as isAppManifestEnabled } from \"#build/nuxt.config.mjs\";\nimport _routes, { handleHotUpdate } from \"#build/routes\";\nimport routerOptions, { hashMode } from \"#build/router.options\";\nimport { globalMiddleware, namedMiddleware } from \"#build/middleware\";\nfunction createCurrentLocation(base, location, renderedPath) {\n  const { pathname, search, hash } = location;\n  const hashPos = base.indexOf(\"#\");\n  if (hashPos > -1) {\n    const slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    if (pathFromHash[0] !== \"/\") {\n      pathFromHash = \"/\" + pathFromHash;\n    }\n    return withoutBase(pathFromHash, \"\");\n  }\n  const displayedPath = withoutBase(pathname, base);\n  const path = !renderedPath || isEqual(displayedPath, renderedPath, { trailingSlash: true }) ? displayedPath : renderedPath;\n  return path + (path.includes(\"?\") ? \"\" : search) + hash;\n}\nconst plugin = defineNuxtPlugin({\n  name: \"nuxt:router\",\n  enforce: \"pre\",\n  async setup(nuxtApp) {\n    let routerBase = useRuntimeConfig().app.baseURL;\n    if (hashMode && !routerBase.includes(\"#\")) {\n      routerBase += \"#\";\n    }\n    const history = routerOptions.history?.(routerBase) ?? (import.meta.client ? hashMode ? createWebHashHistory(routerBase) : createWebHistory(routerBase) : createMemoryHistory(routerBase));\n    const routes = routerOptions.routes ? await routerOptions.routes(_routes) ?? _routes : _routes;\n    let startPosition;\n    const router = createRouter({\n      ...routerOptions,\n      scrollBehavior: (to, from, savedPosition) => {\n        if (from === START_LOCATION) {\n          startPosition = savedPosition;\n          return;\n        }\n        if (routerOptions.scrollBehavior) {\n          router.options.scrollBehavior = routerOptions.scrollBehavior;\n          if (\"scrollRestoration\" in window.history) {\n            const unsub = router.beforeEach(() => {\n              unsub();\n              window.history.scrollRestoration = \"manual\";\n            });\n          }\n          return routerOptions.scrollBehavior(to, START_LOCATION, startPosition || savedPosition);\n        }\n      },\n      history,\n      routes\n    });\n    handleHotUpdate(router, routerOptions.routes ? routerOptions.routes : (routes2) => routes2);\n    if (import.meta.client && \"scrollRestoration\" in window.history) {\n      window.history.scrollRestoration = \"auto\";\n    }\n    nuxtApp.vueApp.use(router);\n    const previousRoute = shallowRef(router.currentRoute.value);\n    router.afterEach((_to, from) => {\n      previousRoute.value = from;\n    });\n    Object.defineProperty(nuxtApp.vueApp.config.globalProperties, \"previousRoute\", {\n      get: () => previousRoute.value\n    });\n    const initialURL = import.meta.server ? nuxtApp.ssrContext.url : createCurrentLocation(routerBase, window.location, nuxtApp.payload.path);\n    const _route = shallowRef(router.currentRoute.value);\n    const syncCurrentRoute = () => {\n      _route.value = router.currentRoute.value;\n    };\n    nuxtApp.hook(\"page:finish\", syncCurrentRoute);\n    router.afterEach((to, from) => {\n      if (to.matched[0]?.components?.default === from.matched[0]?.components?.default) {\n        syncCurrentRoute();\n      }\n    });\n    const route = {};\n    for (const key in _route.value) {\n      Object.defineProperty(route, key, {\n        get: () => _route.value[key],\n        enumerable: true\n      });\n    }\n    nuxtApp._route = shallowReactive(route);\n    nuxtApp._middleware ||= {\n      global: [],\n      named: {}\n    };\n    const error = useError();\n    if (import.meta.client || !nuxtApp.ssrContext?.islandContext) {\n      router.afterEach(async (to, _from, failure) => {\n        delete nuxtApp._processingMiddleware;\n        if (import.meta.client && !nuxtApp.isHydrating && error.value) {\n          await nuxtApp.runWithContext(clearError);\n        }\n        if (failure) {\n          await nuxtApp.callHook(\"page:loading:end\");\n        }\n        if (import.meta.server && failure?.type === 4) {\n          return;\n        }\n        if (import.meta.server && to.redirectedFrom && to.fullPath !== initialURL) {\n          await nuxtApp.runWithContext(() => navigateTo(to.fullPath || \"/\"));\n        }\n      });\n    }\n    try {\n      if (import.meta.server) {\n        await router.push(initialURL);\n      }\n      await router.isReady();\n    } catch (error2) {\n      await nuxtApp.runWithContext(() => showError(error2));\n    }\n    const resolvedInitialRoute = import.meta.client && initialURL !== router.currentRoute.value.fullPath ? router.resolve(initialURL) : router.currentRoute.value;\n    syncCurrentRoute();\n    if (import.meta.server && nuxtApp.ssrContext?.islandContext) {\n      return { provide: { router } };\n    }\n    const initialLayout = nuxtApp.payload.state._layout;\n    router.beforeEach(async (to, from) => {\n      await nuxtApp.callHook(\"page:loading:start\");\n      to.meta = reactive(to.meta);\n      if (nuxtApp.isHydrating && initialLayout && !isReadonly(to.meta.layout)) {\n        to.meta.layout = initialLayout;\n      }\n      nuxtApp._processingMiddleware = true;\n      if (import.meta.client || !nuxtApp.ssrContext?.islandContext) {\n        const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);\n        for (const component of to.matched) {\n          const componentMiddleware = component.meta.middleware;\n          if (!componentMiddleware) {\n            continue;\n          }\n          for (const entry of toArray(componentMiddleware)) {\n            middlewareEntries.add(entry);\n          }\n        }\n        if (isAppManifestEnabled) {\n          const routeRules = await nuxtApp.runWithContext(() => getRouteRules({ path: to.path }));\n          if (routeRules.appMiddleware) {\n            for (const key in routeRules.appMiddleware) {\n              if (routeRules.appMiddleware[key]) {\n                middlewareEntries.add(key);\n              } else {\n                middlewareEntries.delete(key);\n              }\n            }\n          }\n        }\n        for (const entry of middlewareEntries) {\n          const middleware = typeof entry === \"string\" ? nuxtApp._middleware.named[entry] || await namedMiddleware[entry]?.().then((r) => r.default || r) : entry;\n          if (!middleware) {\n            if (import.meta.dev) {\n              throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map((mw) => `'${mw}'`).join(\", \")}.`);\n            }\n            throw new Error(`Unknown route middleware: '${entry}'.`);\n          }\n          try {\n            const result = await nuxtApp.runWithContext(() => middleware(to, from));\n            if (import.meta.server || !nuxtApp.payload.serverRendered && nuxtApp.isHydrating) {\n              if (result === false || result instanceof Error) {\n                const error2 = result || createError({\n                  statusCode: 404,\n                  statusMessage: `Page Not Found: ${initialURL}`\n                });\n                await nuxtApp.runWithContext(() => showError(error2));\n                return false;\n              }\n            }\n            if (result === true) {\n              continue;\n            }\n            if (result === false) {\n              return result;\n            }\n            if (result) {\n              if (isNuxtError(result) && result.fatal) {\n                await nuxtApp.runWithContext(() => showError(result));\n              }\n              return result;\n            }\n          } catch (err) {\n            const error2 = createError(err);\n            if (error2.fatal) {\n              await nuxtApp.runWithContext(() => showError(error2));\n            }\n            return error2;\n          }\n        }\n      }\n    });\n    router.onError(async () => {\n      delete nuxtApp._processingMiddleware;\n      await nuxtApp.callHook(\"page:loading:end\");\n    });\n    router.afterEach(async (to, _from) => {\n      if (to.matched.length === 0) {\n        await nuxtApp.runWithContext(() => showError(createError({\n          statusCode: 404,\n          fatal: false,\n          statusMessage: `Page not found: ${to.fullPath}`,\n          data: {\n            path: to.fullPath\n          }\n        })));\n      }\n    });\n    nuxtApp.hooks.hookOnce(\"app:created\", async () => {\n      try {\n        if (\"name\" in resolvedInitialRoute) {\n          resolvedInitialRoute.name = void 0;\n        }\n        await router.replace({\n          ...resolvedInitialRoute,\n          force: true\n        });\n        router.options.scrollBehavior = routerOptions.scrollBehavior;\n      } catch (error2) {\n        await nuxtApp.runWithContext(() => showError(error2));\n      }\n    });\n    return { provide: { router } };\n  }\n});\nexport default plugin;\n"],"names":["plugin","defineNuxtPlugin","nuxtApp","__temp","__restore","routerBase","useRuntimeConfig","history","routes","routerOptions","__executeAsync","_routes","startPosition","router","createRouter","to","from","savedPosition","START_LOCATION","unsub","handleHotUpdate","routes2","previousRoute","shallowRef","_to","initialURL","_route","syncCurrentRoute","_b","_a","_d","_c","route","key","shallowReactive","useError","_from","failure","navigateTo","showError","error2","resolvedInitialRoute","initialLayout","reactive","isReadonly","middlewareEntries","globalMiddleware","component","componentMiddleware","entry","toArray","getRouteRules","routeRules","middleware","namedMiddleware","r","result","createError","isNuxtError","err"],"mappings":"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","x_google_ignoreList":[0]}