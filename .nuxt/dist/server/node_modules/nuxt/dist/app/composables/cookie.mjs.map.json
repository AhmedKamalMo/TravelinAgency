{"file":"cookie.mjs","mappings":"kjBASA,MAAMA,EAAiB,CACrB,KAAM,IACN,MAAO,GACP,OAASC,GAAQC,EAAM,mBAAmBD,CAAG,CAAC,EAC9C,OAASA,GAAQ,mBAAmB,OAAOA,GAAQ,SAAWA,EAAM,KAAK,UAAUA,CAAG,CAAC,CACzF,EAEgB,SAAAE,EAAUC,EAAMC,EAAO,OACrC,MAAMC,EAAO,CAAE,GAAGN,EAAgB,GAAGK,CAAM,EACtCC,EAAA,SAAAA,EAAA,OAAYC,GAAQA,IAAQH,GACjC,MAAMI,EAAUC,EAAeH,CAAI,GAAK,CAAC,EACrC,IAAAI,EACAJ,EAAK,SAAW,OAClBI,EAAQJ,EAAK,OAAS,IACbA,EAAK,UACdI,EAAQJ,EAAK,QAAQ,QAAQ,EAAI,KAAK,IAAI,GAEtC,MAAAK,EAAaD,IAAU,QAAUA,GAAS,EAE1CE,EAAcC,EAAMF,EAAa,OAASH,EAAQJ,CAAI,KAAKU,EAAAR,EAAK,UAAL,YAAAQ,EAAA,KAAAR,GAAgB,EAC3ES,EAA8HC,EAAIJ,CAAW,EAyEpH,CAC7B,MAAMK,EAAUC,EAAW,EACrBC,EAAwB,IAAM,CAC9Bb,EAAK,UAAYc,EAAQL,EAAO,MAAOP,EAAQJ,CAAI,CAAC,IAGxDa,EAAQ,WAARA,EAAQ,SAAa,CAAC,GAClB,EAAAb,KAAQa,EAAQ,UACdG,EAAQL,EAAO,MAAOE,EAAQ,SAASb,CAAI,CAAC,KAO1Ca,EAAA,SAASb,CAAI,EAAIW,EAAO,MAChCM,EAAkBC,EAAgBL,CAAO,EAAGb,EAAMW,EAAO,MAAOT,CAAI,GACtE,EACMiB,EAASN,EAAQ,MAAM,SAAS,eAAgBE,CAAqB,EACnEF,EAAA,MAAM,SAAS,YAAa,KAC3BM,EAAA,EACAJ,EAAsB,EAC9B,CAAA,CAEI,OAAAJ,CACT,CAOA,SAASN,EAAeH,EAAO,GAAI,CAE/B,OAAOkB,EAAMC,EAAiBH,EAAA,EAAmB,QAAQ,GAAK,GAAIhB,CAAI,CAI1E,CAYA,SAASe,EAAkBK,EAAOtB,EAAMuB,EAAOrB,EAAO,CAAA,EAAI,CACxD,GAAIoB,EAAO,CACL,GAAAC,GAAU,KACZ,OAAOC,EAAUF,EAAOtB,EAAMuB,EAAOrB,CAAI,EAE3C,GAAIuB,EAAUH,EAAOtB,CAAI,IAAM,OACtB,OAAA0B,EAAaJ,EAAOtB,EAAME,CAAI,CACvC,CAEJ","names":["CookieDefaults","val","destr","useCookie","name","_opts","opts","key","cookies","readRawCookies","delay","hasExpired","cookieValue","klona","_a","cookie","ref","nuxtApp","useNuxtApp","writeFinalCookieValue","isEqual","writeServerCookie","useRequestEvent","unhook","parse","getRequestHeader","event","value","setCookie","getCookie","deleteCookie"],"sources":["../../../../../../../../node_modules/nuxt/dist/app/composables/cookie.js"],"sourcesContent":["import { customRef, getCurrentScope, nextTick, onScopeDispose, ref, watch } from \"vue\";\nimport { parse, serialize } from \"cookie-es\";\nimport { deleteCookie, getCookie, getRequestHeader, setCookie } from \"h3\";\nimport destr from \"destr\";\nimport { isEqual } from \"ohash\";\nimport { klona } from \"klona\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRequestEvent } from \"./ssr.js\";\nimport { cookieStore } from \"#build/nuxt.config.mjs\";\nconst CookieDefaults = {\n  path: \"/\",\n  watch: true,\n  decode: (val) => destr(decodeURIComponent(val)),\n  encode: (val) => encodeURIComponent(typeof val === \"string\" ? val : JSON.stringify(val))\n};\nconst store = import.meta.client && cookieStore ? window.cookieStore : void 0;\nexport function useCookie(name, _opts) {\n  const opts = { ...CookieDefaults, ..._opts };\n  opts.filter ??= (key) => key === name;\n  const cookies = readRawCookies(opts) || {};\n  let delay;\n  if (opts.maxAge !== void 0) {\n    delay = opts.maxAge * 1e3;\n  } else if (opts.expires) {\n    delay = opts.expires.getTime() - Date.now();\n  }\n  const hasExpired = delay !== void 0 && delay <= 0;\n  const shouldSetInitialClientCookie = import.meta.client && (hasExpired || cookies[name] === void 0 || cookies[name] === null);\n  const cookieValue = klona(hasExpired ? void 0 : cookies[name] ?? opts.default?.());\n  const cookie = import.meta.client && delay && !hasExpired ? cookieRef(cookieValue, delay, opts.watch && opts.watch !== \"shallow\") : ref(cookieValue);\n  if (import.meta.dev && hasExpired) {\n    console.warn(`[nuxt] not setting cookie \\`${name}\\` as it has already expired.`);\n  }\n  if (import.meta.client) {\n    let channel = null;\n    try {\n      if (!store && typeof BroadcastChannel !== \"undefined\") {\n        channel = new BroadcastChannel(`nuxt:cookies:${name}`);\n      }\n    } catch {\n    }\n    const callback = (force = false) => {\n      if (!force) {\n        if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n          return;\n        }\n      }\n      writeClientCookie(name, cookie.value, opts);\n      cookies[name] = klona(cookie.value);\n      channel?.postMessage({ value: opts.encode(cookie.value) });\n    };\n    const handleChange = (data) => {\n      const value = data.refresh ? readRawCookies(opts)?.[name] : opts.decode(data.value);\n      watchPaused = true;\n      cookie.value = value;\n      cookies[name] = klona(value);\n      nextTick(() => {\n        watchPaused = false;\n      });\n    };\n    let watchPaused = false;\n    const hasScope = !!getCurrentScope();\n    if (hasScope) {\n      onScopeDispose(() => {\n        watchPaused = true;\n        callback();\n        channel?.close();\n      });\n    }\n    if (store) {\n      const changeHandler = (event) => {\n        const changedCookie = event.changed.find((c) => c.name === name);\n        const removedCookie = event.deleted.find((c) => c.name === name);\n        if (changedCookie) {\n          handleChange({ value: changedCookie.value });\n        }\n        if (removedCookie) {\n          handleChange({ value: null });\n        }\n      };\n      store.addEventListener(\"change\", changeHandler);\n      if (hasScope) {\n        onScopeDispose(() => store.removeEventListener(\"change\", changeHandler));\n      }\n    } else if (channel) {\n      channel.onmessage = ({ data }) => handleChange(data);\n    }\n    if (opts.watch) {\n      watch(\n        cookie,\n        () => {\n          if (watchPaused) {\n            return;\n          }\n          callback();\n        },\n        { deep: opts.watch !== \"shallow\" }\n      );\n    }\n    if (shouldSetInitialClientCookie) {\n      callback(shouldSetInitialClientCookie);\n    }\n  } else if (import.meta.server) {\n    const nuxtApp = useNuxtApp();\n    const writeFinalCookieValue = () => {\n      if (opts.readonly || isEqual(cookie.value, cookies[name])) {\n        return;\n      }\n      nuxtApp._cookies ||= {};\n      if (name in nuxtApp._cookies) {\n        if (isEqual(cookie.value, nuxtApp._cookies[name])) {\n          return;\n        }\n        if (import.meta.dev) {\n          console.warn(`[nuxt] cookie \\`${name}\\` was previously set to \\`${opts.encode(nuxtApp._cookies[name])}\\` and is being overridden to \\`${opts.encode(cookie.value)}\\`. This may cause unexpected issues.`);\n        }\n      }\n      nuxtApp._cookies[name] = cookie.value;\n      writeServerCookie(useRequestEvent(nuxtApp), name, cookie.value, opts);\n    };\n    const unhook = nuxtApp.hooks.hookOnce(\"app:rendered\", writeFinalCookieValue);\n    nuxtApp.hooks.hookOnce(\"app:error\", () => {\n      unhook();\n      return writeFinalCookieValue();\n    });\n  }\n  return cookie;\n}\nexport function refreshCookie(name) {\n  if (import.meta.server || store || typeof BroadcastChannel === \"undefined\") {\n    return;\n  }\n  new BroadcastChannel(`nuxt:cookies:${name}`)?.postMessage({ refresh: true });\n}\nfunction readRawCookies(opts = {}) {\n  if (import.meta.server) {\n    return parse(getRequestHeader(useRequestEvent(), \"cookie\") || \"\", opts);\n  } else if (import.meta.client) {\n    return parse(document.cookie, opts);\n  }\n}\nfunction serializeCookie(name, value, opts = {}) {\n  if (value === null || value === void 0) {\n    return serialize(name, value, { ...opts, maxAge: -1 });\n  }\n  return serialize(name, value, opts);\n}\nfunction writeClientCookie(name, value, opts = {}) {\n  if (import.meta.client) {\n    document.cookie = serializeCookie(name, value, opts);\n  }\n}\nfunction writeServerCookie(event, name, value, opts = {}) {\n  if (event) {\n    if (value !== null && value !== void 0) {\n      return setCookie(event, name, value, opts);\n    }\n    if (getCookie(event, name) !== void 0) {\n      return deleteCookie(event, name, opts);\n    }\n  }\n}\nconst MAX_TIMEOUT_DELAY = 2147483647;\nfunction cookieRef(value, delay, shouldWatch) {\n  let timeout;\n  let unsubscribe;\n  let elapsed = 0;\n  const internalRef = shouldWatch ? ref(value) : { value };\n  if (getCurrentScope()) {\n    onScopeDispose(() => {\n      unsubscribe?.();\n      clearTimeout(timeout);\n    });\n  }\n  return customRef((track, trigger) => {\n    if (shouldWatch) {\n      unsubscribe = watch(internalRef, trigger);\n    }\n    function createExpirationTimeout() {\n      elapsed = 0;\n      clearTimeout(timeout);\n      const timeRemaining = delay - elapsed;\n      const timeoutLength = timeRemaining < MAX_TIMEOUT_DELAY ? timeRemaining : MAX_TIMEOUT_DELAY;\n      timeout = setTimeout(() => {\n        elapsed += timeoutLength;\n        if (elapsed < delay) {\n          return createExpirationTimeout();\n        }\n        internalRef.value = void 0;\n        trigger();\n      }, timeoutLength);\n    }\n    return {\n      get() {\n        track();\n        return internalRef.value;\n      },\n      set(newValue) {\n        createExpirationTimeout();\n        internalRef.value = newValue;\n        trigger();\n      }\n    };\n  });\n}\n"],"version":3}