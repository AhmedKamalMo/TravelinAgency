{"version":3,"file":"router.mjs","sources":["../../../../../../../../node_modules/nuxt/dist/app/composables/router.js"],"sourcesContent":["import { getCurrentInstance, hasInjectionContext, inject, onScopeDispose } from \"vue\";\nimport { sanitizeStatusCode } from \"h3\";\nimport { hasProtocol, isScriptProtocol, joinURL, parseQuery, parseURL, withQuery } from \"ufo\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { PageRouteSymbol } from \"../components/injections.js\";\nimport { createError, showError } from \"./error.js\";\nexport const useRouter = () => {\n  return useNuxtApp()?.$router;\n};\nexport const useRoute = () => {\n  if (import.meta.dev && !getCurrentInstance() && isProcessingMiddleware()) {\n    console.warn(\"[nuxt] Calling `useRoute` within middleware may lead to misleading results. Instead, use the (to, from) arguments passed to the middleware to access the new and old routes.\");\n  }\n  if (hasInjectionContext()) {\n    return inject(PageRouteSymbol, useNuxtApp()._route);\n  }\n  return useNuxtApp()._route;\n};\nexport const onBeforeRouteLeave = (guard) => {\n  const unsubscribe = useRouter().beforeEach((to, from, next) => {\n    if (to === from) {\n      return;\n    }\n    return guard(to, from, next);\n  });\n  onScopeDispose(unsubscribe);\n};\nexport const onBeforeRouteUpdate = (guard) => {\n  const unsubscribe = useRouter().beforeEach(guard);\n  onScopeDispose(unsubscribe);\n};\n// @__NO_SIDE_EFFECTS__\nexport function defineNuxtRouteMiddleware(middleware) {\n  return middleware;\n}\nexport const addRouteMiddleware = (name, middleware, options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const global = options.global || typeof name !== \"string\";\n  const mw = typeof name !== \"string\" ? name : middleware;\n  if (!mw) {\n    console.warn(\"[nuxt] No route middleware passed to `addRouteMiddleware`.\", name);\n    return;\n  }\n  if (global) {\n    nuxtApp._middleware.global.push(mw);\n  } else {\n    nuxtApp._middleware.named[name] = mw;\n  }\n};\nconst isProcessingMiddleware = () => {\n  try {\n    if (useNuxtApp()._processingMiddleware) {\n      return true;\n    }\n  } catch {\n    return false;\n  }\n  return false;\n};\nconst URL_QUOTE_RE = /\"/g;\nexport const navigateTo = (to, options) => {\n  to ||= \"/\";\n  const toPath = typeof to === \"string\" ? to : \"path\" in to ? resolveRouteObject(to) : useRouter().resolve(to).href;\n  if (import.meta.client && options?.open) {\n    const { target = \"_blank\", windowFeatures = {} } = options.open;\n    const features = Object.entries(windowFeatures).filter(([_, value]) => value !== void 0).map(([feature, value]) => `${feature.toLowerCase()}=${value}`).join(\", \");\n    open(toPath, target, features);\n    return Promise.resolve();\n  }\n  const isExternalHost = hasProtocol(toPath, { acceptRelative: true });\n  const isExternal = options?.external || isExternalHost;\n  if (isExternal) {\n    if (!options?.external) {\n      throw new Error(\"Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.\");\n    }\n    const { protocol } = new URL(toPath, import.meta.client ? window.location.href : \"http://localhost\");\n    if (protocol && isScriptProtocol(protocol)) {\n      throw new Error(`Cannot navigate to a URL with '${protocol}' protocol.`);\n    }\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (import.meta.client && !isExternal && inMiddleware) {\n    if (options?.replace) {\n      if (typeof to === \"string\") {\n        const { pathname, search, hash } = parseURL(to);\n        return {\n          path: pathname,\n          ...search && { query: parseQuery(search) },\n          ...hash && { hash },\n          replace: true\n        };\n      }\n      return { ...to, replace: true };\n    }\n    return to;\n  }\n  const router = useRouter();\n  const nuxtApp = useNuxtApp();\n  if (import.meta.server) {\n    if (nuxtApp.ssrContext) {\n      const fullPath = typeof to === \"string\" || isExternal ? toPath : router.resolve(to).fullPath || \"/\";\n      const location2 = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, fullPath);\n      const redirect = async function(response) {\n        await nuxtApp.callHook(\"app:redirected\");\n        const encodedLoc = location2.replace(URL_QUOTE_RE, \"%22\");\n        const encodedHeader = encodeURL(location2, isExternalHost);\n        nuxtApp.ssrContext._renderResponse = {\n          statusCode: sanitizeStatusCode(options?.redirectCode || 302, 302),\n          body: `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`,\n          headers: { location: encodedHeader }\n        };\n        return response;\n      };\n      if (!isExternal && inMiddleware) {\n        router.afterEach((final) => final.fullPath === fullPath ? redirect(false) : void 0);\n        return to;\n      }\n      return redirect(!inMiddleware ? void 0 : (\n        /* abort route navigation */\n        false\n      ));\n    }\n  }\n  if (isExternal) {\n    nuxtApp._scope.stop();\n    if (options?.replace) {\n      location.replace(toPath);\n    } else {\n      location.href = toPath;\n    }\n    if (inMiddleware) {\n      if (!nuxtApp.isHydrating) {\n        return false;\n      }\n      return new Promise(() => {\n      });\n    }\n    return Promise.resolve();\n  }\n  return options?.replace ? router.replace(to) : router.push(to);\n};\nexport const abortNavigation = (err) => {\n  if (import.meta.dev && !isProcessingMiddleware()) {\n    throw new Error(\"abortNavigation() is only usable inside a route middleware handler.\");\n  }\n  if (!err) {\n    return false;\n  }\n  err = createError(err);\n  if (err.fatal) {\n    useNuxtApp().runWithContext(() => showError(err));\n  }\n  throw err;\n};\nexport const setPageLayout = (layout) => {\n  const nuxtApp = useNuxtApp();\n  if (import.meta.server) {\n    if (import.meta.dev && getCurrentInstance() && nuxtApp.payload.state._layout !== layout) {\n      console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout on the server within a component as this will cause hydration errors.\");\n    }\n    nuxtApp.payload.state._layout = layout;\n  }\n  if (import.meta.dev && nuxtApp.isHydrating && nuxtApp.payload.serverRendered && nuxtApp.payload.state._layout !== layout) {\n    console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout during hydration as this will cause hydration errors.\");\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (inMiddleware || import.meta.server || nuxtApp.isHydrating) {\n    const unsubscribe = useRouter().beforeResolve((to) => {\n      to.meta.layout = layout;\n      unsubscribe();\n    });\n  }\n  if (!inMiddleware) {\n    useRoute().meta.layout = layout;\n  }\n};\nexport function resolveRouteObject(to) {\n  return withQuery(to.path || \"\", to.query || {}) + (to.hash || \"\");\n}\nexport function encodeURL(location2, isExternalHost = false) {\n  const url = new URL(location2, \"http://localhost\");\n  if (!isExternalHost) {\n    return url.pathname + url.search + url.hash;\n  }\n  if (location2.startsWith(\"//\")) {\n    return url.toString().replace(url.protocol, \"\");\n  }\n  return url.toString();\n}\n"],"names":["useRouter","_a","useNuxtApp","useRoute","hasInjectionContext","inject","PageRouteSymbol","defineNuxtRouteMiddleware","middleware","addRouteMiddleware","name","options","nuxtApp","global","mw","isProcessingMiddleware","URL_QUOTE_RE","navigateTo","to","toPath","resolveRouteObject","isExternalHost","hasProtocol","isExternal","protocol","isScriptProtocol","inMiddleware","router","fullPath","location2","joinURL","useRuntimeConfig","redirect","response","encodedLoc","encodedHeader","encodeURL","sanitizeStatusCode","final","withQuery","url"],"mappings":"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","x_google_ignoreList":[0]}