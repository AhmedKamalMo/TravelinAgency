import{ref as m,shallowRef as p,toRef as b,getCurrentInstance as O,onServerPrefetch as V,unref as E}from"vue";import{useNuxtApp as R}from"../nuxt.mjs";import{createError as S}from"./error.mjs";import{asyncDataDefaults as f}from"../../../../../_virtual/virtual_nuxt_F__TravelinAgency_.nuxt_nuxt.config.mjs";const j=t=>t==="defer"||t===!1;function I(...t){var h,_;const s=typeof t[t.length-1]=="string"?t.pop():void 0;typeof t[0]!="string"&&t.unshift(s);let[r,d,e={}]=t;if(typeof r!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof d!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const a=R(),v=!import.meta.prerender||!((h=a.ssrContext)!=null&&h._sharedPrerenderCache)?d:()=>{const c=a.ssrContext._sharedPrerenderCache.get(r);if(c)return c;const l=Promise.resolve().then(()=>a.runWithContext(d));return a.ssrContext._sharedPrerenderCache.set(r,l),l},P=()=>f.value,g=()=>a.isHydrating?a.payload.data[r]:a.static.data[r];e.server??(e.server=!0),e.default??(e.default=P),e.getCachedData??(e.getCachedData=g),e.lazy??(e.lazy=!1),e.immediate??(e.immediate=!0),e.deep??(e.deep=f.deep),e.dedupe??(e.dedupe="cancel");const u=e.getCachedData(r,a),y=u!=null;if(!a._asyncData[r]||!e.immediate){(_=a.payload._errors)[r]??(_[r]=f.errorValue);const c=e.deep?m:p;a._asyncData[r]={data:c(y?u:e.default()),pending:m(!y),error:b(a.payload._errors,r),status:m("idle"),_default:e.default}}const n={...a._asyncData[r]};delete n._default,n.refresh=n.execute=(c={})=>{if(a._asyncDataPromises[r]){if(j(c.dedupe??e.dedupe))return a._asyncDataPromises[r];a._asyncDataPromises[r].cancelled=!0}if(c._initial||a.isHydrating&&c._initial!==!1){const i=c._initial?u:e.getCachedData(r,a);if(i!=null)return Promise.resolve(i)}n.pending.value=!0,n.status.value="pending";const l=new Promise((i,o)=>{try{i(v(a))}catch(w){o(w)}}).then(async i=>{if(l.cancelled)return a._asyncDataPromises[r];let o=i;e.transform&&(o=await e.transform(i)),e.pick&&(o=K(o,e.pick)),a.payload.data[r]=o,n.data.value=o,n.error.value=f.errorValue,n.status.value="success"}).catch(i=>{if(l.cancelled)return a._asyncDataPromises[r];n.error.value=S(i),n.data.value=E(e.default()),n.status.value="error"}).finally(()=>{l.cancelled||(n.pending.value=!1,delete a._asyncDataPromises[r])});return a._asyncDataPromises[r]=l,a._asyncDataPromises[r]},n.clear=()=>H(a,r);const C=()=>n.refresh({_initial:!0});if(e.server!==!1&&a.payload.serverRendered&&e.immediate){const c=C();O()?V(()=>c):a.hook("app:created",async()=>{await c})}const D=Promise.resolve(a._asyncDataPromises[r]).then(()=>n);return Object.assign(D,n),D}function H(t,s){s in t.payload.data&&(t.payload.data[s]=void 0),s in t.payload._errors&&(t.payload._errors[s]=f.errorValue),t._asyncData[s]&&(t._asyncData[s].data.value=void 0,t._asyncData[s].error.value=f.errorValue,t._asyncData[s].pending.value=!1,t._asyncData[s].status.value="idle"),s in t._asyncDataPromises&&(t._asyncDataPromises[s]&&(t._asyncDataPromises[s].cancelled=!0),t._asyncDataPromises[s]=void 0)}function K(t,s){const r={};for(const d of s)r[d]=t[d];return r}export{I as useAsyncData};
//# sourceMappingURL=asyncData.mjs.map
