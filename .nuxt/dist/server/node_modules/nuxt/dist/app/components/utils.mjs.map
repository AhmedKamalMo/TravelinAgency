{"version":3,"file":"utils.mjs","sources":["../../../../../../../../node_modules/nuxt/dist/app/components/utils.js"],"sourcesContent":["import { Transition, createStaticVNode, h } from \"vue\";\nimport { isString, isPromise, isArray, isObject } from \"@vue/shared\";\nimport { START_LOCATION } from \"#build/pages\";\nexport const _wrapInTransition = (props, children) => {\n  return { default: () => import.meta.client && props ? h(Transition, props === true ? {} : props, children) : children.default?.() };\n};\nconst ROUTE_KEY_PARENTHESES_RE = /(:\\w+)\\([^)]+\\)/g;\nconst ROUTE_KEY_SYMBOLS_RE = /(:\\w+)[?+*]/g;\nconst ROUTE_KEY_NORMAL_RE = /:\\w+/g;\nfunction generateRouteKey(route) {\n  const source = route?.meta.key ?? route.path.replace(ROUTE_KEY_PARENTHESES_RE, \"$1\").replace(ROUTE_KEY_SYMBOLS_RE, \"$1\").replace(ROUTE_KEY_NORMAL_RE, (r) => route.params[r.slice(1)]?.toString() || \"\");\n  return typeof source === \"function\" ? source(route) : source;\n}\nexport function isChangingPage(to, from) {\n  if (to === from || from === START_LOCATION) {\n    return false;\n  }\n  if (generateRouteKey(to) !== generateRouteKey(from)) {\n    return true;\n  }\n  const areComponentsSame = to.matched.every(\n    (comp, index) => comp.components && comp.components.default === from.matched[index]?.components?.default\n  );\n  if (areComponentsSame) {\n    return false;\n  }\n  return true;\n}\nexport function createBuffer() {\n  let appendable = false;\n  const buffer = [];\n  return {\n    getBuffer() {\n      return buffer;\n    },\n    push(item) {\n      const isStringItem = isString(item);\n      if (appendable && isStringItem) {\n        buffer[buffer.length - 1] += item;\n      } else {\n        buffer.push(item);\n      }\n      appendable = isStringItem;\n      if (isPromise(item) || isArray(item) && item.hasAsync) {\n        buffer.hasAsync = true;\n      }\n    }\n  };\n}\nexport function vforToArray(source) {\n  if (isArray(source)) {\n    return source;\n  } else if (isString(source)) {\n    return source.split(\"\");\n  } else if (typeof source === \"number\") {\n    if (import.meta.dev && !Number.isInteger(source)) {\n      console.warn(`The v-for range expect an integer value but got ${source}.`);\n    }\n    const array = [];\n    for (let i = 0; i < source; i++) {\n      array[i] = i;\n    }\n    return array;\n  } else if (isObject(source)) {\n    if (source[Symbol.iterator]) {\n      return Array.from(\n        source,\n        (item) => item\n      );\n    } else {\n      const keys = Object.keys(source);\n      const array = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        array[i] = source[key];\n      }\n      return array;\n    }\n  }\n  return [];\n}\nexport function getFragmentHTML(element, withoutSlots = false) {\n  if (element) {\n    if (element.nodeName === \"#comment\" && element.nodeValue === \"[\") {\n      return getFragmentChildren(element, [], withoutSlots);\n    }\n    if (withoutSlots) {\n      const clone = element.cloneNode(true);\n      clone.querySelectorAll(\"[data-island-slot]\").forEach((n) => {\n        n.innerHTML = \"\";\n      });\n      return [clone.outerHTML];\n    }\n    return [element.outerHTML];\n  }\n}\nfunction getFragmentChildren(element, blocks = [], withoutSlots = false) {\n  if (element && element.nodeName) {\n    if (isEndFragment(element)) {\n      return blocks;\n    } else if (!isStartFragment(element)) {\n      const clone = element.cloneNode(true);\n      if (withoutSlots) {\n        clone.querySelectorAll(\"[data-island-slot]\").forEach((n) => {\n          n.innerHTML = \"\";\n        });\n      }\n      blocks.push(clone.outerHTML);\n    }\n    getFragmentChildren(element.nextSibling, blocks, withoutSlots);\n  }\n  return blocks;\n}\nexport function elToStaticVNode(el, staticNodeFallback) {\n  const fragment = el ? getFragmentHTML(el) : staticNodeFallback ? [staticNodeFallback] : void 0;\n  if (fragment) {\n    return createStaticVNode(fragment.join(\"\"), fragment.length);\n  }\n  return h(\"div\");\n}\nfunction isStartFragment(element) {\n  return element.nodeName === \"#comment\" && element.nodeValue === \"[\";\n}\nfunction isEndFragment(element) {\n  return element.nodeName === \"#comment\" && element.nodeValue === \"]\";\n}\n"],"names":["_wrapInTransition","props","children","_a","ROUTE_KEY_PARENTHESES_RE","ROUTE_KEY_SYMBOLS_RE","ROUTE_KEY_NORMAL_RE","generateRouteKey","route","source","r","isChangingPage","to","from","START_LOCATION","comp","index","_b"],"mappings":"wDAGY,MAACA,EAAoB,CAACC,EAAOC,KAChC,CAAE,QAAS,WAA2F,OAAAC,EAAAD,EAAS,UAAT,YAAAC,EAAA,KAAAD,GAAsB,GAE/HE,EAA2B,mBAC3BC,EAAuB,eACvBC,EAAsB,QAC5B,SAASC,EAAiBC,EAAO,CAC/B,MAAMC,GAASD,GAAA,YAAAA,EAAO,KAAK,MAAOA,EAAM,KAAK,QAAQJ,EAA0B,IAAI,EAAE,QAAQC,EAAsB,IAAI,EAAE,QAAQC,EAAsBI,GAAC,OAAK,QAAAP,EAAAK,EAAM,OAAOE,EAAE,MAAM,CAAC,CAAC,IAAvB,YAAAP,EAA0B,aAAc,GAAE,EACvM,OAAO,OAAOM,GAAW,WAAaA,EAAOD,CAAK,EAAIC,CACxD,CACO,SAASE,EAAeC,EAAIC,EAAM,CACvC,OAAID,IAAOC,GAAQA,IAASC,EACnB,GAELP,EAAiBK,CAAE,IAAML,EAAiBM,CAAI,EACzC,GAEiB,CAAAD,EAAG,QAAQ,MACnC,CAACG,EAAMC,aAAU,OAAAD,EAAK,YAAcA,EAAK,WAAW,YAAYE,GAAAd,EAAAU,EAAK,QAAQG,CAAK,IAAlB,YAAAb,EAAqB,aAArB,YAAAc,EAAiC,SAClG,CAKH","x_google_ignoreList":[0]}