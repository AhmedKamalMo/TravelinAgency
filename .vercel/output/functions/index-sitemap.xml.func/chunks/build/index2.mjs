import{computed as e,defineComponent as a,h as t,onServerPrefetch as n,ref as r,shallowRef as s,toRef as o,getCurrentInstance as i,unref as l}from"vue";import{getIconCSS as c}from"@iconify/utils/lib/css/icon";import{getIcon as u,loadIcon as d,Icon as m}from"@iconify/vue";import{c as f,S as y,T as p,H as v,e as _,u as g}from"./server.mjs";async function m$1(e,a){if(!e)return null;const t=u(e);if(t)return t;let n;const r=d(e).catch((()=>(console.warn(`[Icon] failed to load icon \`${e}\``),null)));return a>0?await Promise.race([r,new Promise((t=>{n=setTimeout((()=>{console.warn(`[Icon] loading icon \`${e}\` timed out after ${a}ms`),t()}),a)}))]).finally((()=>clearTimeout(n))):await r,u(e)}function I$1(a){const t=f().icon,n=(t.collections||[]).sort(((e,a)=>a.length-e.length));return e((()=>{var e;const r=a(),s=r.startsWith(t.cssSelectorPrefix)?r.slice(t.cssSelectorPrefix.length):r,o=(null==(e=t.aliases)?void 0:e[s])||s;if(!o.includes(":")){const e=n.find((e=>o.startsWith(e+"-")));return e?e+":"+o.slice(e.length+1):o}return o}))}function w$1(e,a){if(!1!==e)return!0===e||null===e?a:e}const h="NUXT_ICONS_SERVER_CSS";const D=a({name:"NuxtIconCss",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(a){const r=y(),s=f().icon,o=e((()=>a.name?s.cssSelectorPrefix+a.name:"")),i=e((()=>"."+function(e){return e.replace(/([^\w-])/g,"\\$1")}(o.value)));return n((async()=>{var e;{const t=p().icon||{};if(null==(e=null==t?void 0:t.serverKnownCssClasses)||!e.includes(o.value)){const e=await m$1(a.name,s.fetchTimeout).catch((()=>null));if(!e)return null;let t=r.vueApp._context.provides[h];if(t||(t=r.vueApp._context.provides[h]=new Map,r.runWithContext((()=>{v({style:[()=>{let e=Array.from(t.values()).sort().join("");return s.cssLayer&&(e=`@layer ${s.cssLayer} {${e}}`),{innerHTML:e}}]},{tagPriority:"low"})}))),a.name&&!t.has(a.name)){const n=function(e,t=!0){let n=i.value;s.cssWherePseudo&&(n=`:where(${n})`);const r=c(e,{iconSelector:n,format:"compressed",customise:w$1(a.customize,s.customize)});return s.cssLayer&&t?`@layer ${s.cssLayer} { ${r} }`:r}(e,!1);t.set(a.name,n)}return null}}})),()=>t("span",{class:["iconify",o.value]})}});function I(...e){var a;const t="string"==typeof e[e.length-1]?e.pop():void 0;"string"!=typeof e[0]&&e.unshift(t);let[c,u,d={}]=e;if("string"!=typeof c)throw new TypeError("[nuxt] [asyncData] key must be a string.");if("function"!=typeof u)throw new TypeError("[nuxt] [asyncData] handler must be a function.");const m=y(),f=u;d.server??(d.server=!0),d.default??(d.default=()=>_.value),d.getCachedData??(d.getCachedData=()=>m.isHydrating?m.payload.data[c]:m.static.data[c]),d.lazy??(d.lazy=!1),d.immediate??(d.immediate=!0),d.deep??(d.deep=_.deep),d.dedupe??(d.dedupe="cancel");const p=d.getCachedData(c,m),v=null!=p;if(!m._asyncData[c]||!d.immediate){(a=m.payload._errors)[c]??(a[c]=_.errorValue);const e=d.deep?r:s;m._asyncData[c]={data:e(v?p:d.default()),pending:r(!v),error:o(m.payload._errors,c),status:r("idle"),_default:d.default}}const h={...m._asyncData[c]};delete h._default,h.refresh=h.execute=(e={})=>{if(m._asyncDataPromises[c]){if((e=>"defer"===e||!1===e)(e.dedupe??d.dedupe))return m._asyncDataPromises[c];m._asyncDataPromises[c].cancelled=!0}if(e._initial||m.isHydrating&&!1!==e._initial){const a=e._initial?p:d.getCachedData(c,m);if(null!=a)return Promise.resolve(a)}h.pending.value=!0,h.status.value="pending";const a=new Promise(((e,a)=>{try{e(f(m))}catch(e){a(e)}})).then((async e=>{if(a.cancelled)return m._asyncDataPromises[c];let t=e;d.transform&&(t=await d.transform(e)),d.pick&&(t=function(e,a){const t={};for(const n of a)t[n]=e[n];return t}(t,d.pick)),m.payload.data[c]=t,h.data.value=t,h.error.value=_.errorValue,h.status.value="success"})).catch((e=>{if(a.cancelled)return m._asyncDataPromises[c];h.error.value=g(e),h.data.value=l(d.default()),h.status.value="error"})).finally((()=>{a.cancelled||(h.pending.value=!1,delete m._asyncDataPromises[c])}));return m._asyncDataPromises[c]=a,m._asyncDataPromises[c]},h.clear=()=>function(e,a){a in e.payload.data&&(e.payload.data[a]=void 0),a in e.payload._errors&&(e.payload._errors[a]=_.errorValue),e._asyncData[a]&&(e._asyncData[a].data.value=void 0,e._asyncData[a].error.value=_.errorValue,e._asyncData[a].pending.value=!1,e._asyncData[a].status.value="idle"),a in e._asyncDataPromises&&(e._asyncDataPromises[a]&&(e._asyncDataPromises[a].cancelled=!0),e._asyncDataPromises[a]=void 0)}(m,c);if(!1!==d.server&&m.payload.serverRendered&&d.immediate){const e=h.refresh({_initial:!0});i()?n((()=>e)):m.hook("app:created",(async()=>{await e}))}const D=Promise.resolve(m._asyncDataPromises[c]).then((()=>h));return Object.assign(D,h),D}const w=a({name:"NuxtIconSvg",props:{name:{type:String,required:!0},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(e,{slots:a}){y();const r=f().icon,s=I$1((()=>e.name)),o="i-"+s.value;return s.value&&n((async()=>{await I(o,(async()=>await m$1(s.value,r.fetchTimeout)),{deep:!1})})),()=>t(m,{icon:s.value,ssr:!0,customise:w$1(e.customize,r.customize)},a)}}),P=a({name:"NuxtIcon",props:{name:{type:String,required:!0},mode:{type:String,required:!1,default:null},size:{type:[Number,String],required:!1,default:null},customize:{type:[Function,Boolean,null],default:null,required:!1}},setup(a,{slots:n}){const r=y(),s=f().icon,o=I$1((()=>a.name)),i=e((()=>{var e;return(null==(e=r.vueApp)?void 0:e.component(o.value))||("svg"===(a.mode||s.mode)?w:D)})),l=e((()=>{const e=a.size||s.size;return e?{fontSize:Number.isNaN(+e)?e:e+"px"}:null}));return()=>t(i.value,{...s.attrs,name:o.value,class:s.class,style:l.value,customize:a.customize},n)}}),$=Object.freeze({__proto__:null,default:P});export{I,$ as i,P as q};
//# sourceMappingURL=index2.mjs.map
